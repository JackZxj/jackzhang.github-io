<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang学习笔记ch2</title>
      <link href="/2019/03/06/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0ch2/"/>
      <url>/2019/03/06/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0ch2/</url>
      
        <content type="html"><![CDATA[<p>依旧是Go语言的学习。虽然已经有了一定的Java基础，但是Go的一些结构特性还真是别具特色。。。从Java语言的特性切换到Go过来虽然说能够很快的理解并接受，但是用的时候还是回感慨这些设计还真是精妙，甚至有种编程语言本该如此设计的感觉。。</p><p>本篇的备注信息较多，方便给初学者一个参考，也方便我自己过后回顾的时候能够很快回忆起来。<br><a id="more"></a></p><h2 id="ch2-程序结构"><a href="#ch2-程序结构" class="headerlink" title="ch2 程序结构"></a>ch2 程序结构</h2><p>本章的主要内容是Go语言的编程结构，一些基础的我可能没有特别强调，但是对于Go的包、作用域、特殊用法等方面我这边做了一些测试。当然主要是按书上的例子实现的。下面直接放代码，建议参考注释看代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>ch2/GoStruct.go</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><code class="hljs Golang">package main<br><br>import (<br>  "fmt"<br>  "strconv"<br><br>  "flag"<br>  "strings"<br><br>  "ch2/Kaierwen"<br>)<br><br>// 多变量声明<br>func ShengMing() &#123;<br>  // 在多变量的短声明中，至少要有一个新变量的声明，如果有重复变量的话会当作赋值，如：<br>  // strconv.Atoi(s string) (i int, err error)<br>  num1, err := strconv.Atoi("1209")<br>  num2, err := strconv.Atoi("12a1")<br>  // 上述两条语句都声明并赋值了err变量，但是实际上只有第一条成功声明了err并进行了赋值，第二句仅作为赋值作用<br>  if err == nil &#123;<br>    fmt.Printf("num2 + num1 = %d\n", num2 + num1)<br>  &#125;<br>  // 下面的语句会出现编译失败，因为没有新变量出现在声明中<br>  // num2, err := strconv.Atoi("1211")<br>&#125;<br><br>// 指针的一些特殊使用---&gt;用在标识<br>// 全局变量只能使用var声明，不能短声明<br>var n = flag.Bool("n", false, "omit trailing newline")    //自定义标识符，用于换行<br>var sep = flag.String("s", " ", "separator")        //自定义标识符，用于输出多参数<br>func echo1() &#123;<br>  // flag需要先调用Parse来使得自定义标识生效<br>  flag.Parse()<br>  // 将命令行参数输出，多参数之间用sep隔开，sep若没有声明，则默认是全局变量里声明的空格<br>  fmt.Print(strings.Join(flag.Args(), *sep))<br>  // 如果没有-n参数就执行换行，如果有-n就不执行换行<br>  if !*n &#123;<br>    fmt.Print("\n")<br>  &#125;<br>&#125;<br><br>// 指针的另一种声明方式<br>func newPointer() &#123;<br>  // new声明一个地址变量并默认赋该类型的初值<br>  p := new(int)<br>  fmt.Println("指针*p =",*p)<br>  // new不是关键值，因此可以可以声明变量名为new，则此时就无法使用new声明指针<br>&#125;<br><br>// 高效的多重赋值<br>func zuiDaGongYinShu() &#123;<br>  x, y := 456,2661<br>  if x &lt; y &#123;<br>    // 两数交换<br>    x, y = y, x<br>  &#125;<br>  for y != 0 &#123;<br>    x, y = y, x % y<br>  &#125;<br>  fmt.Printf("最大公约数为%d\n",x)<br>&#125;<br><br>// 类型声明<br>// 所有的类型都拥有一个强制转换类型的函数 T(),T为类型名<br>type Celsius float64<br>type Fahrenheit float64<br><br>const (<br>    AbsoluteZeroC Celsius = -273.15<br>    FreezingC Celsius = 0<br>    Boiling Celsius = 100<br>)<br><br>func CtoF(c Celsius) Fahrenheit &#123;<br>  return Fahrenheit(c * 9 / 5 + 32)     // 强制类型转换，不是函数的意思<br>&#125;<br><br>func FtoC(f Fahrenheit) Celsius &#123;<br>  return Celsius((f - 32) * 5 / 9)     // 强制类型转换，不是函数的意思<br>&#125;<br><br>// 相当于重写Java中的toString()方法，用于自定义输出格式<br>func (c Celsius) String() string &#123;<br>  return fmt.Sprintf("%g°C", c)<br>&#125;<br><br>func TestType() &#123;<br>  var a Celsius = 0<br>  var b Fahrenheit = 0<br>  // 在强制转换时，不改变底层的数值，如下所示<br>  fmt.Println("Celsius(a) == Fahrenheit(b) ?", a == Celsius(b))       //输出true<br>  // 定义的类型支持底层的基本运算法则，如<br>  fmt.Println("Celsius(a) - Celsius(b) = ?", a - Celsius(b))        // 输出true<br>  // 显示调用String()方法<br>  fmt.Println("显式：a =", a.String())<br>  // 隐式调用String()方法<br>  fmt.Printf("隐式：a = %v, %s\n", a, a)<br>  fmt.Println("a = ", a)<br>  // 不调用String()方法<br>  // 由此可以看出自定义类型可以直接调用其原本类型的标准输出方式输出<br>  fmt.Printf("不调用：a = %g, %.2f\n", a, a)<br>&#125;<br><br>// go语言的特殊规则---包级别<br>func TestPackage() &#123;<br>  k := Kaierwen.Kai(100)<br>  fmt.Printf("k = %v, Zero = %s, CtoK = %s\n", k, Kaierwen.Zero, Kaierwen.CtoK)<br>  <br>  // 只有首字母大写的才能被包外的包调用<br>  // n := Kaierwen.num(100)<br>  // fmt.Printf("n = %v, zero = %s, ctoK = %s\n", n, Kaierwen.zero, Kaierwen.ctoK)<br><br>  Kaierwen.PaTest()<br>&#125;<br><br>// 同名变量的处理规则<br>var g = "g"<br>func f() string &#123;<br>  return "FFF"<br>&#125;<br>func NameTest() &#123;<br>  fmt.Println(f, f())   // 输出包内函数的地址和函数运行结果<br>  f := "f"        // 覆盖包内函数，重新被定义为字符串"f"<br>  fmt.Println(f)      // 输出"f"<br>  // fmt.Println(f())   // 被重写后无法调用包内函数<br>  if true &#123;<br>    f := "fff"      // 块内局部变量覆盖函数的局部变量<br>    fmt.Println(f)<br>  &#125;<br>  fmt.Println(f)      // 重新输出函数内局部变量<br><br>  // 覆盖的骚操作（实际上工程中还是不要这么用，还是按照取名规范来）<br>  x := "hello"<br>  for _, x := range x &#123;<br>    x := x + 'A' - 'a'<br>    fmt.Printf("%c", x)<br>  &#125;<br>  fmt.Println()<br><br>  fmt.Println(g)      // 没有被覆盖的情况<br>&#125;<br><br>func gg() string &#123;<br>  return "GGG"<br>&#125;<br><br>// if作用域的测试<br>func LandTest() &#123;<br>  if x := f(); x == "fff" &#123;<br>    fmt.Println("x==fff")<br>  &#125; else if y := gg(); x == y &#123;<br>    fmt.Println("x==y")<br>  &#125; else &#123;<br>    fmt.Println("x =", x, "\ty =",y)<br>  &#125;<br>  // fmt.Println(x, y)    //无法调用，因为不在变量声明的作用范围内<br>&#125;<br><br><br>// 灵活的switch语句<br>func SwitchTest() &#123;<br>  switch f() &#123;<br>  // case是自带break的，case按照从上到下寻找到第一个匹配的后就自动退出<br>  case "fff":<br>    fmt.Println("switch : fff")<br>  case "FFF":<br>    fmt.Println("switch : FFF")<br>  // 不是必选项<br>  default :<br>    fmt.Println("switch : not f()")<br>  &#125;<br><br>  y := 2<br>  // 无标签switch，选择判断结果为true的结果执行<br>  switch &#123;<br>  // case支持多匹配<br>  case y == 1, y != 2:<br>    fmt.Println("y==1 or y!=2")<br>  case y == 2:<br>    fmt.Println("y==2")<br>  &#125;<br><br>  //type switch<br>  var x interface&#123;&#125;<br>  <br>  switch i := x.(type) &#123;<br>  case int:<br>    fmt.Println("x 是 int 型")<br>  case float64:<br>    fmt.Println("x 是 float64 型")<br>  case func(int) float64:<br>    fmt.Println("x 是 func(int) 型")<br>  case bool, string:<br>    fmt.Println("x 是 bool 或 string 型" )<br>  case nil:<br>    fmt.Println("x 的类型 :%T",i)<br>  default:<br>    fmt.Println("未知型")     <br>  &#125;<br><br>  // fallthrough 特别标记符在switch中的作用<br>  // fallthrough可以忽略下一个case的判断直接执行下一个case的内容<br>  switch &#123;<br>  case false:<br>    fmt.Println("1,false")<br>    fallthrough<br>  case true:<br>    fmt.Println("2,true")<br>    fallthrough<br>  case false:<br>    fmt.Println("3,false")<br>    fallthrough<br>  case true:<br>    fmt.Println("4,true")<br>    if y == 2 &#123;<br>      fmt.Println("可以通过break来提前结束fallthrough")<br>      break<br>    &#125;<br>    // 或者取消fallthrough标记来结束执行下一条case<br>    fallthrough<br>  case false:<br>    fmt.Println("5, false")<br>  &#125;<br><br>&#125;<br><br>var myNum int<br><br>// 特别的作用域覆盖问题<br>// 当在块内要调用块外变量时，需要特别注意不能使用短声明对多个变量声明<br>func init() &#123;<br>  // 使用下面的myNum会被声明成局部变量<br>  // 造成的最大影响是全局变量不会被按照预期的值而初始化<br>  // myNum, err := strconv.Atoi("123")<br>  // 正确的初始化(使用var声明新变量，然后使用多赋值改变值）：<br>  var err error<br>  myNum, err = strconv.Atoi("123")<br>  if err != nil &#123;<br>    fmt.Println("error num!")<br>  &#125;<br>&#125;<br><br>func main() &#123;<br>  ShengMing()<br><br>  echo1()<br><br>  newPointer()<br><br>  zuiDaGongYinShu()<br><br>  TestType()<br><br>  TestPackage()<br><br>  NameTest()<br><br>  LandTest()<br><br>  SwitchTest()<br><br>  fmt.Println("myNum =", myNum)<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>ch2/Kaierwen/Kaierwen.go</strong><br><figure class="highlight Golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> Kaierwen<br><span class="hljs-comment">// 包名、文件名、文件夹名相同才能调用包(**--存疑--**)</span><br><span class="hljs-comment">// 补充（3月9日）：</span><br><span class="hljs-comment">// 文件夹名实际上就是包名，go的调用包需要保证包内有一个与包名同名的文件，作为该包的调用入口</span><br><span class="hljs-comment">// 包内的方法或者变量在实际工程中，并不一定全部都要声明在同一个文件里</span><br><span class="hljs-comment">// 在保证必须只有一个同名文件的基础下，可以按照实际功能在本包内创建若干辅助文件</span><br><span class="hljs-comment">// 只要文件内声明属于该包，那么就可以被该包调用</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 另外，包内依然可以声明包，例如golang的官方包hash</span><br><span class="hljs-comment">// hash包下不仅有hash.go，还有adler32、crc32、crc64、fnv四个包内包</span><br><span class="hljs-comment">// 通过"hash/adler32","hash/crc32","hash/crc64","hash/fnv"来调用包内包</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><span class="hljs-comment">// 包外可见类型</span><br><span class="hljs-keyword">type</span> Kai <span class="hljs-keyword">float64</span><br><span class="hljs-comment">// 包外不可见类型</span><br><span class="hljs-keyword">type</span> num <span class="hljs-keyword">int8</span><br><br><span class="hljs-keyword">const</span>(<br>  <span class="hljs-comment">//包外可见常量</span><br>    Zero Kai = <span class="hljs-number">0</span><br>    <span class="hljs-comment">//包外不可见常量</span><br>    zero Kai = <span class="hljs-number">0</span><br>)<br><span class="hljs-comment">// 包外可见全局变量</span><br><span class="hljs-keyword">var</span> CtoK Kai = <span class="hljs-number">273.15</span><br><span class="hljs-comment">// 包外不可见全局变量</span><br><span class="hljs-keyword">var</span> ctoK Kai = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k Kai)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%gK"</span>, k)<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>ch2/Kaierwen/PaTest.go</strong><br><figure class="highlight Golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// 不同文件同包测试</span><br><span class="hljs-comment">// 编译器会把该文件的函数编译到一个包内</span><br><span class="hljs-keyword">package</span> Kaierwen<br><br><span class="hljs-comment">// 尽管在另一个文件内已经声明了fmt包，但是在本文件内任然要再次声明调用</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-comment">// 包内变量的初始化，按照依赖的顺序进行初始化</span><br><span class="hljs-keyword">var</span> a = b + c   <span class="hljs-comment">// 第三个初始化的变量</span><br><span class="hljs-keyword">var</span> b = f()     <span class="hljs-comment">// 第二个初始化的变量</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>     <span class="hljs-comment">// 第一个初始化的变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> c + <span class="hljs-number">1</span> &#125;<br><br><span class="hljs-keyword">var</span> nums [<span class="hljs-number">256</span>]<span class="hljs-keyword">byte</span>  <span class="hljs-comment">// 已经默认初始化为0了</span><br><br><span class="hljs-comment">// 包内初始化函数，用于初始化复杂变量，如数组等</span><br><span class="hljs-comment">// 其作用相当于Java类内的块函数&#123;&#125;</span><br><span class="hljs-comment">// 和块函数一样，init函数是对外不可见的，因此不能被调用或者引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 当用于数组类型时，可以不用管值，因此可以用省略写法</span><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nums &#123;     <span class="hljs-comment">// 等价于 for i, _ := range nums</span><br>    nums[i] = nums[i / <span class="hljs-number">2</span>] + <span class="hljs-keyword">byte</span>(i &amp; <span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PaTest</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Printf(<span class="hljs-string">"This is a package test, a = %d, b = %d, c = %d\n"</span>, a, b, c)<br><br>  fmt.Printf(<span class="hljs-string">"nums : %v\n"</span>, nums)<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我原本以为本章没有很多内容，可以很快就弄完，但是实际上还是花了一些时间才看完弄清的。部分的特性书上没有提及或者并没有详细的给出程序示例或解释（如switch的用法)，我自己在网上搜集，也自己补充了一些理解，仅供参考，如有错误，请联系我，谢谢！</p><h2 id="可供参考的资料"><a href="#可供参考的资料" class="headerlink" title="可供参考的资料"></a>可供参考的资料</h2><p><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Golang标准库文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 开发入门 </tag>
            
            <tag> 程序结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang学习笔记ch1</title>
      <link href="/2019/03/04/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0ch1/"/>
      <url>/2019/03/04/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0ch1/</url>
      
        <content type="html"><![CDATA[<p>太菜找不到工作了，愁愁愁愁愁。</p><p>看了一下字节跳动的招聘很多都是golang的岗位，新的独角兽果然就是敢于用新鲜事物。。。</p><p>本文只是个人的学习代码记录，仅供参考。</p><p>参考书籍：《Go程序设计语言》 【美】艾伦 A.A. 多诺万，布莱恩 W. 柯尼汉 著，李道兵、高博、旁向才等译 机械工业出版社 2017年</p><a id="more"></a><h2 id="ch1-入门"><a href="#ch1-入门" class="headerlink" title="ch1 入门"></a>ch1 入门</h2><p>与我之前学过的教材不同，以往的教材往往第一章是语言介绍以及配置安装等杂项，本书的第一章是一些go程序实例，尽管还没有正式学习go语言，但是通过这些实例可以一窥golang的一些特性。书中入门的内容较多，各个实例我基本都一一手动敲入实现了，下面直接放代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>ch1/hello.go</strong><br><figure class="highlight Golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">"fmt"</span><br>  <span class="hljs-string">"unsafe"</span><br>  <span class="hljs-string">"os"</span><br>  <span class="hljs-string">"strings"</span><br>  <span class="hljs-string">"bufio"</span><br>)<br><br><span class="hljs-comment">//定义一个函数类型</span><br><span class="hljs-keyword">type</span> callb <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span><br><br>//测试函数回调函数<br><span class="hljs-title">func</span> <span class="hljs-title">testCallBack</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, f callb)</span></span> &#123;<br>  fmt.Print(<span class="hljs-string">"testCallBack:"</span>)<br>  f(x)<br>  fmt.Println()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callBack</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>  fmt.Print(<span class="hljs-string">"huidiao:"</span>, x, <span class="hljs-string">"\n"</span>)<br>  <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">//数组传参测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLen</span><span class="hljs-params">(p []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">"无长度"</span>, <span class="hljs-built_in">len</span>(p))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLen2</span><span class="hljs-params">(p [3]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>  <span class="hljs-comment">//注意两个输出除了换行外还有空格的区别</span><br>  fmt.Println(<span class="hljs-string">"len2:"</span>,<span class="hljs-built_in">len</span>(p))<br>  fmt.Print(<span class="hljs-string">"len:"</span>,<span class="hljs-built_in">len</span>(p))<br>&#125;<br><br><span class="hljs-comment">//测试多返值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MultiReturn</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-comment">//高级版foreach——range</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rangeTest</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Print(<span class="hljs-string">"\n*************** rangeTest Start ***************\n"</span>)<br>  nums := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;<br>  kvs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span> : <span class="hljs-string">"apple"</span>, <span class="hljs-string">"b"</span> : <span class="hljs-string">"banana"</span>&#125;<br>  <span class="hljs-keyword">var</span> sum, sumt <span class="hljs-keyword">int</span><br>  <span class="hljs-comment">//两种缺省index</span><br>  <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>    sum += num<br>  &#125;<br>  <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> nums &#123;<br>    <span class="hljs-keyword">if</span> num != <span class="hljs-number">0</span> &#123;<br>      sumt++;<br>    &#125;<br>  &#125;<br>  fmt.Printf(<span class="hljs-string">"rangeTest sum:%d, sumt:%d\n"</span>, sum, sumt)<br>  <span class="hljs-comment">//index测试</span><br>  <span class="hljs-keyword">for</span> i, num := <span class="hljs-keyword">range</span> <span class="hljs-string">"我是初学者golang is 6, u too"</span> &#123;<br>    <span class="hljs-keyword">if</span> num == <span class="hljs-string">'是'</span> &#123;<br>      fmt.Printf(<span class="hljs-string">"6是第%d个元素\n"</span>, i + <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//用range测试遍历map</span><br>  <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> kvs &#123;<br>    fmt.Printf(<span class="hljs-string">"%s -&gt; %s\n"</span>, i, v)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//map测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapTest</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Print(<span class="hljs-string">"\n*************** mapTest Start ***************\n"</span>)<br><br>  <span class="hljs-comment">//定义map变量，无初始化,默认为nil</span><br>  <span class="hljs-keyword">var</span> numMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><br>  <span class="hljs-comment">//使用make函数初始化map变量，此时map被创建，长度为0</span><br>  numMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br><br>  <span class="hljs-comment">// map的声明方式</span><br>  numMap[ <span class="hljs-string">"1"</span> ] = <span class="hljs-string">"111"</span><br>  numMap[ <span class="hljs-string">"2"</span> ] = <span class="hljs-string">"222"</span><br>  numMap[ <span class="hljs-string">"3"</span> ] = <span class="hljs-string">"333"</span><br><br>  <span class="hljs-comment">//使用range遍历map</span><br>  <span class="hljs-keyword">for</span> s := <span class="hljs-keyword">range</span> numMap &#123;<br>    fmt.Printf(<span class="hljs-string">"%s is %s\n"</span>, s, numMap[s])<br>  &#125;<br>  <span class="hljs-comment">//返回的值为mapName[key]的值以及是否查询到该值，查询不到时返回为 map类型的初始化值和false</span><br>  x, y := numMap[<span class="hljs-string">"1"</span>]<br>  a, b := numMap[<span class="hljs-string">"4"</span>]<br>  fmt.Printf(<span class="hljs-string">"%s is %s, %s is %s\n"</span>, x, y, a, b)<br><br>  <span class="hljs-comment">//delete方法</span><br>  <span class="hljs-built_in">delete</span>(numMap, <span class="hljs-string">"1"</span>)<br>  x, y = numMap[<span class="hljs-string">"1"</span>]<br>  fmt.Printf(<span class="hljs-string">"after delete, %s is %s\n"</span>, x, y)<br>&#125;<br><br><span class="hljs-comment">//类型转换测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typeChange</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Print(<span class="hljs-string">"\n*************** typeChange Start ***************\n"</span>)<br><br>  x := <span class="hljs-number">12.51</span>  <span class="hljs-comment">//这样声明默认是float64类型</span><br>  y := <span class="hljs-number">3</span>    <span class="hljs-comment">//默认为int类型</span><br>  <span class="hljs-keyword">var</span> z <span class="hljs-keyword">float64</span><br>  <span class="hljs-comment">//缺少类型自动转换，因此需要手动强制转换，以下表达式为错误</span><br>  <span class="hljs-comment">//z = x / y</span><br>  <span class="hljs-comment">//float和double也不是自动转换</span><br>  <span class="hljs-comment">//z = x / float32(y)</span><br>  <span class="hljs-comment">//正确写法</span><br>  z = x / <span class="hljs-keyword">float64</span>(y)<br>  fmt.Printf(<span class="hljs-string">"x is %T,y is %T,z=%.3f\n"</span>, x, y, z)<br><br>  <span class="hljs-comment">//go的int类型根据系统判断，系统为32位则为int32，64位为int64</span><br>  <span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">111</span><br>  <span class="hljs-keyword">var</span> b <span class="hljs-keyword">int32</span> = <span class="hljs-number">222</span><br>  <span class="hljs-comment">//int 和 int32并不是同一种类型，不能加减，因此下面是错误</span><br>  <span class="hljs-comment">//var c int = a + b</span><br>  <span class="hljs-keyword">var</span> c <span class="hljs-keyword">int32</span> = <span class="hljs-keyword">int32</span>(a) + b<br>  <span class="hljs-keyword">var</span> d <span class="hljs-keyword">int64</span> = <span class="hljs-number">444</span><br>  <span class="hljs-comment">//因为int根据系统判断，就算在64位系统上也不能直接相加，因此下面报错</span><br>  <span class="hljs-comment">//var e = d + a</span><br>  e := <span class="hljs-keyword">int</span>(d) + a<br>  fmt.Printf(<span class="hljs-string">"a is %T, len is %d\nb is %T, len is %d\nc=%d\ne=%d\n"</span>, a, unsafe.Sizeof(a), b, unsafe.Sizeof(b), c, e)<br>&#125;<br><br><span class="hljs-comment">//输入测试，在运行时输入参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inputTest</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">"\n******* inputTest ******\n"</span>)<br>  <span class="hljs-comment">//下面两种输出结果相同（无[]包住）</span><br>  <span class="hljs-comment">//手动输出</span><br>  <span class="hljs-comment">//os.Args[0]为编译生成的exe的路径</span><br>  s, sep := <span class="hljs-string">""</span>, <span class="hljs-string">" "</span><br>  <span class="hljs-keyword">for</span> _, str := <span class="hljs-keyword">range</span> os.Args[ : ] &#123;<br>    s += str + sep<br>  &#125;<br>  fmt.Println(s)<br><br>  <span class="hljs-comment">//使用join方法</span><br>  fmt.Println(strings.Join(os.Args[ : ], <span class="hljs-string">" "</span>))<br><br>  <span class="hljs-comment">//下面两种输出结果是一样的（有[]包住）</span><br>  <span class="hljs-comment">//无格式输出（适用于slice类型）</span><br>  fmt.Println(os.Args[<span class="hljs-number">1</span> : ])<br><br>  <span class="hljs-comment">//格式化输出</span><br>  fmt.Printf(<span class="hljs-string">"%v\n"</span>, os.Args[<span class="hljs-number">1</span> : ])<br>&#125;<br><br><span class="hljs-comment">//出入测试，采用流输入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inputTest2</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">"\n********** inputTest2(可能会中断退出，原因不明) ************\n"</span>)<br>  counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] <span class="hljs-keyword">int</span>)<br>  input := bufio.NewScanner(os.Stdin)<br>  <span class="hljs-keyword">for</span> input.Scan() &#123;<br>    counts[input.Text()]++<br>  &#125;<br>  <span class="hljs-keyword">for</span> s, i := <span class="hljs-keyword">range</span> counts &#123;<br>    fmt.Printf(<span class="hljs-string">"%s -&gt; %d\n"</span>, s, i)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  y := <span class="hljs-number">111</span><br>  fmt.Print(<span class="hljs-string">"hello"</span>, y, <span class="hljs-string">"\n"</span>)<br>  <span class="hljs-keyword">var</span> x = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>  fmt.Printf(<span class="hljs-string">"%v\n"</span>, x)<br>  fmt.Print(<span class="hljs-string">"ooo\n"</span>)<br>  testCallBack(y, callBack)<br>  testCallBack(y, <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    fmt.Print(<span class="hljs-string">"回调:"</span>, x, <span class="hljs-string">"\n"</span>)<br>    <span class="hljs-keyword">return</span> x<br>  &#125;)<br>  getLen(x)<br>  <span class="hljs-comment">//getLen2(x) //调用失败无法调用定长</span><br>  xx := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>  getLen2(xx)<br>  _, m1, m2 := MultiReturn()<br>  fmt.Println(<span class="hljs-string">"\nm1,m2为："</span>, m1, m2)<br>  rangeTest()<br>  <span class="hljs-comment">//字符串长度问题</span><br>  fmt.Printf(<span class="hljs-string">"\n****** 字符串长度测试 ********\n“ni”的长度为%d,“我”的长度为%d\n"</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">"ni"</span>), <span class="hljs-built_in">len</span>(<span class="hljs-string">"我"</span>))<br>  mapTest()<br>  typeChange()<br><br>  inputTest()<br><br>  inputTest2()<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>ch1/fetchTest.go</strong><br><figure class="highlight Golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">"fmt"</span><br>  <span class="hljs-comment">//"io/ioutil"</span><br>  <span class="hljs-string">"io"</span><br>  <span class="hljs-string">"net/http"</span><br>  <span class="hljs-string">"os"</span><br>  <span class="hljs-string">"strings"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span> : ] &#123;<br>    <span class="hljs-comment">// 自动补充http前缀</span><br>    <span class="hljs-keyword">if</span> !(strings.HasPrefix(url, <span class="hljs-string">"http://"</span>)) || !(strings.HasPrefix(url, <span class="hljs-string">"https://"</span>)) &#123;<br>      url = <span class="hljs-string">"http://"</span> + url<br>    &#125;<br>    resp, err := http.Get(url)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Fprintf(os.Stderr, <span class="hljs-string">"fetch: %v\n"</span>, err)<br>      os.Exit(<span class="hljs-number">1</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 输出状态码</span><br>      fmt.Println(<span class="hljs-string">"state code:"</span>, resp.Status)<br>    &#125;<br>    <span class="hljs-comment">// 两种读取方式，第一种为一次性读取完整个页面后才输出</span><br>    <span class="hljs-comment">// b, err := ioutil.ReadAll(resp.Body)</span><br>    <span class="hljs-comment">//第二种为按照web页面传输的数据来输出</span><br>    b, err := io.Copy(os.Stdout, resp.Body)<br>    resp.Body.Close()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Fprintf(os.Stderr, <span class="hljs-string">"fetch: reading %s : %v\n"</span>, url, err)<br>      os.Exit(<span class="hljs-number">1</span>)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">"%s"</span>, b)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>ch1/fetchMulti.go</strong><br><figure class="highlight Golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">"fmt"</span><br>  <span class="hljs-string">"io"</span><br>  <span class="hljs-string">"io/ioutil"</span><br>  <span class="hljs-string">"net/http"</span><br>  <span class="hljs-string">"os"</span><br>  <span class="hljs-string">"time"</span><br>  <span class="hljs-string">"strings"</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  start := time.Now()<br>  <span class="hljs-comment">//声明通道变量</span><br>  ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br>  <span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span> : ] &#123;<br>    <span class="hljs-keyword">if</span> !(strings.HasPrefix(url, <span class="hljs-string">"http://"</span>)) || !(strings.HasPrefix(url, <span class="hljs-string">"https://"</span>)) &#123;<br>      url = <span class="hljs-string">"http://"</span> + url<br>    &#125;<br>    <span class="hljs-keyword">go</span> fetch(url, ch)   <span class="hljs-comment">//启动一个goruntime</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span> : ] &#123;<br>    fmt.Println(&lt;- ch)    <span class="hljs-comment">//从通道接收</span><br>  &#125;<br>  fmt.Printf(<span class="hljs-string">"%.2fs elapsed \n"</span>, time.Since(start).Seconds())<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">string</span>)</span></span> &#123;<br>  start := time.Now()<br>  resp, err := http.Get(url)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    ch &lt;- fmt.Sprint(err) <span class="hljs-comment">//发送到通道ch、</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  nbytes, err := io.Copy(ioutil.Discard, resp.Body)<br>  resp.Body.Close()     <span class="hljs-comment">//关闭页面</span><br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    ch &lt;- fmt.Sprintf(<span class="hljs-string">"While reading %s : %v"</span>, url, err)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  secs := time.Since(start).Seconds()<br>  ch &lt;- fmt.Sprintf(<span class="hljs-string">"%.2fs\t\t%7d\t\t%s"</span>, secs, nbytes, url)<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>ch1/server1.go</strong><br><figure class="highlight Golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">"fmt"</span><br>  <span class="hljs-string">"log"</span><br>  <span class="hljs-string">"net/http"</span><br>  <span class="hljs-string">"sync"</span><br><br>  <span class="hljs-string">"image"</span><br>  <span class="hljs-string">"image/color"</span><br>  <span class="hljs-string">"image/gif"</span><br>  <span class="hljs-string">"io"</span><br>  <span class="hljs-string">"math"</span><br>  <span class="hljs-string">"math/rand"</span><br><br>  <span class="hljs-string">"strconv"</span><br>)<br><br><span class="hljs-keyword">var</span> mu sync.Mutex     <span class="hljs-comment">//信号量,用于线程锁（pv操作）</span><br><span class="hljs-keyword">var</span> count <span class="hljs-keyword">int</span>     <span class="hljs-comment">//全局变量，计数访问次数</span><br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.Black, color.RGBA&#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xFF</span>&#125;, color.RGBA&#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xFF</span>&#125;&#125;<br><br><span class="hljs-keyword">const</span> (<br>  blackIndex = <span class="hljs-number">0</span>    <span class="hljs-comment">//画板第1种颜色</span><br>  greenIndex = <span class="hljs-number">1</span>    <span class="hljs-comment">//画板第2种颜色</span><br>  blueIndex = <span class="hljs-number">2</span>   <span class="hljs-comment">//画板第3种颜色</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Print(<span class="hljs-string">"start\n"</span>)<br>  http.HandleFunc(<span class="hljs-string">"/"</span>, handler)               <span class="hljs-comment">//设置处理函数</span><br>  http.HandleFunc(<span class="hljs-string">"/count"</span>, counter)              <span class="hljs-comment">//设置处理函数</span><br>  http.HandleFunc(<span class="hljs-string">"/show"</span>, shower)              <span class="hljs-comment">//设置处理函数</span><br>  <span class="hljs-comment">//可以直接在函数种声明</span><br>  http.HandleFunc(<span class="hljs-string">"/lisaru"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    lisaru(w)<br>  &#125;)<br>  <span class="hljs-comment">//在url里输入参数改变丽萨如图的样式，可以修改4个参数，不同参数用&amp;分割，如：</span><br>  <span class="hljs-comment">//http://localhost:8000/newlisaru?nframes=100&amp;cycles=5&amp;size=200</span><br>  http.HandleFunc(<span class="hljs-string">"/newlisaru"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    req := r.URL.Query()<br><br>    auto := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] <span class="hljs-keyword">string</span>)<br>    auto[<span class="hljs-string">"cycles"</span>]  = <span class="hljs-string">"5"</span>     <span class="hljs-comment">//x震荡器变化个数</span><br>    <span class="hljs-comment">// auto["res"]    = "0.001"   //角度分辨率</span><br>    auto[<span class="hljs-string">"size"</span>]  = <span class="hljs-string">"100"</span>     <span class="hljs-comment">//画布为-size ~ +size</span><br>    auto[<span class="hljs-string">"nframes"</span>] = <span class="hljs-string">"64"</span>      <span class="hljs-comment">//gif中共包含64帧</span><br>    auto[<span class="hljs-string">"delay"</span>] = <span class="hljs-string">"8"</span>     <span class="hljs-comment">//10ms的帧延时</span><br>    <span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> auto &#123;<br>      <span class="hljs-keyword">if</span> vv := req.Get(k); vv != <span class="hljs-string">""</span> &#123;<br>        auto[k] = vv<br>      &#125;<br>    &#125;<br>    cycles, _ := strconv.Atoi(auto[<span class="hljs-string">"cycles"</span>])<br>    size, _ := strconv.Atoi(auto[<span class="hljs-string">"size"</span>])<br>    nframes, _ := strconv.Atoi(auto[<span class="hljs-string">"nframes"</span>])<br>    delay, _ := strconv.Atoi(auto[<span class="hljs-string">"delay"</span>])<br><br>    newlisaru(w, cycles, size, nframes, delay)<br>  &#125;)<br><br><br>  log.Fatal(http.ListenAndServe(<span class="hljs-string">"localhost:8000"</span>, <span class="hljs-literal">nil</span>))   <span class="hljs-comment">//设置监听端口</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  <span class="hljs-comment">//当访问localhost:8000/asd时，页面显示url.path = "/asd"</span><br>  fmt.Fprintf(w, <span class="hljs-string">"url.path = %q\n"</span>, r.URL.Path)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  mu.Lock()<br>  count++;<br>  fmt.Fprintf(w, <span class="hljs-string">"count : %d"</span>, count)<br>  mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shower</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintf(w, <span class="hljs-string">"%s \t %s \t %s\n"</span>, r.Method, r.URL, r.Proto)<br>  <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Header &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">"Header[%q] = %q\n"</span>, k, v)<br>  &#125;<br>  fmt.Fprintf(w, <span class="hljs-string">"host = %q\n"</span>, r.Host)<br>  fmt.Fprintf(w, <span class="hljs-string">"remoteAddr = %q\n"</span>, r.RemoteAddr)<br>  <span class="hljs-keyword">if</span> err := r.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Print(err)<br>  &#125;<br>  <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">"Form[%q] = %q\n"</span>, k, v)<br>  &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lisaru</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br>  <span class="hljs-keyword">const</span> (<br>    cycles  = <span class="hljs-number">5</span>     <span class="hljs-comment">//x震荡器变化个数</span><br>    res   = <span class="hljs-number">0.001</span>   <span class="hljs-comment">//角度分辨率</span><br>    size  = <span class="hljs-number">100</span>   <span class="hljs-comment">//画布为-size ~ +size</span><br>    nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">//gif中共包含64帧</span><br>    delay = <span class="hljs-number">8</span>     <span class="hljs-comment">//10ms的帧延时</span><br>  )<br><br>  freq := rand.Float64() * <span class="hljs-number">3.0</span>  <span class="hljs-comment">//y的震荡频率</span><br>  anim := gif.GIF&#123;LoopCount : nframes&#125;  <span class="hljs-comment">//GIF结构体初始化属性值</span><br>  phase := <span class="hljs-number">0.0</span>          <span class="hljs-comment">//偏移量</span><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>    rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>)<br>    img := image.NewPaletted(rect, palette)<br>    <span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles * <span class="hljs-number">2</span> * math.Pi; t += res &#123;<br>      x := math.Sin(t)<br>      y := math.Sin(t * freq + phase)<br>      img.SetColorIndex(size + <span class="hljs-keyword">int</span>(x * size + <span class="hljs-number">0.5</span>), size + <span class="hljs-keyword">int</span>(y * size + <span class="hljs-number">0.5</span>), greenIndex)<br>    &#125;<br>    <span class="hljs-keyword">for</span> p := <span class="hljs-number">0</span>; p &lt; <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>; p++ &#123;<br>      img.SetColorIndex(p, size, blueIndex)<br>      img.SetColorIndex(size, p, blueIndex)<br>    &#125;<br>    phase += <span class="hljs-number">0.1</span><br>    anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>    anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>  &#125;<br>  gif.EncodeAll(out, &amp;anim)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newlisaru</span><span class="hljs-params">(out io.Writer, cycles, size, nframes, delay <span class="hljs-keyword">int</span>)</span></span> &#123;<br>  <span class="hljs-comment">/*<br>  const (<br>    cycles  = 5     //x震荡器变化个数<br>    res   = 0.001   //角度分辨率<br>    size  = 100   //画布为-size ~ +size<br>    nframes = 64    //gif中共包含64帧<br>    delay = 8     //10ms的帧延时<br>  )<br>  */</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-number">0.001</span><br><br>  freq := rand.Float64() * <span class="hljs-number">3.0</span>  <span class="hljs-comment">//y的震荡频率</span><br>  anim := gif.GIF&#123;LoopCount : nframes&#125;  <span class="hljs-comment">//GIF结构体初始化属性值</span><br>  phase := <span class="hljs-number">0.0</span>          <span class="hljs-comment">//偏移量</span><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>    rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>)<br>    img := image.NewPaletted(rect, palette)<br>    <span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; <span class="hljs-keyword">float64</span>(cycles) * <span class="hljs-number">2</span> * math.Pi; t += res &#123;<br>      x := math.Sin(t)<br>      y := math.Sin(t * freq + phase)<br>      img.SetColorIndex(size + <span class="hljs-keyword">int</span>(x * <span class="hljs-keyword">float64</span>(size) + <span class="hljs-number">0.5</span>), size + <span class="hljs-keyword">int</span>(y * <span class="hljs-keyword">float64</span>(size) + <span class="hljs-number">0.5</span>), greenIndex)<br>    &#125;<br>    <span class="hljs-keyword">for</span> p := <span class="hljs-number">0</span>; p &lt; <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>; p++ &#123;<br>      img.SetColorIndex(p, size, blueIndex)<br>      img.SetColorIndex(size, p, blueIndex)<br>    &#125;<br>    phase += <span class="hljs-number">0.1</span><br>    anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>    anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>  &#125;<br>  gif.EncodeAll(out, &amp;anim)<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因为不是教程向的，仅仅是我的个人学习笔记，代码写的不好请不要在意。</p><p>请监督我继续写下去（如果有人看的话hhh）</p><p>有问题欢迎指出。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>可供参考的资料：<br><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Golang标准库文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 开发入门 </tag>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常用网络协议合集</title>
      <link href="/2019/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%90%88%E9%9B%86/"/>
      <url>/2019/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Sad!!!</p><a id="more"></a><h2 id="物理层（比特流）"><a href="#物理层（比特流）" class="headerlink" title="物理层（比特流）"></a>物理层（比特流）</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>物理层协议通常只定义与传输有关的接口特性。如 EIA RS-232-C、ADSL、SONET/SDH 等。</p><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><ol><li>中继器（转发器）<br>将信号整形、放大再转发出去。（信号再生） </li><li>集线器 Hub（多端口中继器）<br>将信号再生转发到除了输入端口外的其他端口</li></ol><h2 id="数据链路层（帧）"><a href="#数据链路层（帧）" class="headerlink" title="数据链路层（帧）"></a>数据链路层（帧）</h2><h3 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h3><ol><li>停止-等待协议<br>发一个收一个，收到回复，收不下就不回复。 </li><li>后退 N 帧协议 GBN（go-back-N）<br>可以连续发送 N 帧，接收窗口只能按顺序接收帧。接收窗口采用累计确认形式。发送窗口收不到确认帧就无法滑动窗口，超时重传未确认的帧。 最大发送窗口数 2n-1（n 为帧的比特编号的位数） </li><li>选择重传协议 SR<br>连续发送 N 帧，最大可接收 N 帧。发送窗口超时重传或者收到接收窗口的 NAK（否定帧）时重传。 最大窗口为 2(n-1)（n 为帧的比特编号的位数） </li><li>ALOHA 协议 <ol><li>纯 ALOHA 协议<br>想发就发，冲突不收，超时重传。 </li><li>时隙 ALOHA 协议 同步各站时间，划分时隙，只有时隙开始时才能发送数据 </li></ol></li><li>CSMA 协议（载波侦听多路访问）<br>先侦听信道，确定空闲时发送。 <ol><li>1-坚持 CSMA（直率系发送）<br>侦听到信道空闲时发送数据的概率为 1 </li><li>非坚持 CSMA（佛系发送）<br>侦听到信道空闲则发送，信道忙就不再监听，等待一个随机时间后再重新监听。</li><li>P 坚持 CSMA（傲娇系发送）<br>监听信道忙则等待下一个时隙再监听，监听信道空闲则有 P 概率发送数据，1-P 的概率等待下一次监听判断是否发送。 </li></ol></li><li>CSMA/CD（载波监听多点接入/碰撞检测协议）——用于物理链路<br>先听后发，边听边发（区别于 CSMA），冲突停发，随机重发（截断二进制指数退 避算法）<br>算法内容如下：<br>① 取最短退避时间 2t<br>② 定义参数 k，k=min(重传次数，10)<br>③ 等待时间系数 r=random(0, 1, 2, ……, 2k-1)，退避时间 T = 2t * r<br>④ 重传超过 16 仍失败时，抛弃此帧，向高层报告出错。 </li><li>CSMA/CA（载波监听多点接入/碰撞避免协议）——用于无线局域网 <ol><li>预约信道<br>要发送信号时向其他站点通知自己的所需的传输时间，让其他站在这个期间不 发送数据，避免碰撞。 </li><li>ACK 帧<br>接收站收到给自己的数据帧（除了广播帧和组播帧）后，需要给发送站回复一 个 ACK 帧。发送站未收到ACK 帧则认为发送失败，超时后重传。 </li><li>RTS/CTS 帧<br>用于解决“隐蔽站”问题属于可选项。<br>退避算法：二进制指数退避算法，但是冲突时也要发完数据。 </li></ol></li><li>令牌传递协议——逻辑通路必须为环网，适用于高负载通信<br>① 持有令牌时才能发送数据（将令牌帧改为数据帧发送），不发送数据时转发令牌。<br>② 接收站复制数据帧，将原数据帧的“响应比特”修改为收到状态，继续转发数据帧；数据帧回到发送站才算完成一轮数据传送。<br>③ 一个站的发送帧数超过最大帧数时释放令牌继续轮询。 </li><li>PPP（点对点协议）——面向广域网<br>面向连接，不提供可靠传输（只检错不纠错，无序号，无流量控制，错就丢弃），只 支持全双工链路，PPP 帧是面向字节的，默认采用字节填充法，所有的 PPP 帧的长度都 是整数字节的，信息装载量 0~1500B。  </li><li>HDLC 协议（高级数据链路控制协议）——面向广域网，由 ISO 制定<br>面向连接，提供可靠传输（只检错不纠错，有序号和确认机制，有流量控制），只 支持全双工链路，面向比特，采用比特填充法（逢五个 1 插入一个 0）。 </li></ol><h3 id="设备-1"><a href="#设备-1" class="headerlink" title="设备"></a>设备</h3><ol><li>网桥 <ol><li>透明网桥（非最佳路由）<br>自学习算法：站 A 的数据帧哪个端口来，则从哪个端口出去必能找到 A。 </li><li>源路由网桥（最佳路由）<br>发送发现帧，再回收发现帧，最后生成一个任一点最短全路由。 </li></ol></li><li>局域网交换机<br>多端口网桥，各站独占带宽。 <ol><li>直通式交换<br>只检查目的 MAC（即只检查数据帧的前 6B（不含前缀码），就转发数据帧） </li><li>存储转发式交换<br>收下数据帧，检查错误，错则丢弃，正确则排队转发。 </li></ol></li></ol><h2 id="网络层（IP-数据报或称分组、包）"><a href="#网络层（IP-数据报或称分组、包）" class="headerlink" title="网络层（IP 数据报或称分组、包）"></a>网络层（IP 数据报或称分组、包）</h2><h3 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h3><ol><li>IP 协议 无连接、不可靠、尽力而为型 </li><li>NAT(网络地址转换)——重复使用 IP 地址 <ol><li>在公司内部，每台机器都有一个形如 192.168.Y.Z 的地址。 </li><li>当一个分组离开公司的时候，首先要通过一个 NAT 盒，此 NAT 盒将内部的 IP 源地 址转换成该公司所拥有的真实 IP 地址，198.60.42.12。<br>（实际上是 Socket 的映射——工作在传输层）<br>三段私有 IP 地址<br>a) 10.0.0.0~10.255.255.255/8<br>b)172.16.0.0~172.31.255.255/12<br>c)192.168.0.0~192.168.255.255/16  </li></ol></li><li>子网掩码以及 CIDR<br>子网掩码——划分子网<br>CIDR——组成超网（路由聚合） </li><li>ARP（地址解析协议）——网络层协议<br>已知 IP 地址，求物理地址（MAC 地址）<br>通过广播目的 MAC 为 FF-FF-FF-FF-FF-FF 的请求分组，目的 IP 主机收到后发送响应 APR 分组。 </li><li>DHCP（动态主机配置协议）——应用层协议，基于 UDP<br>自动给网络中的主机分配临时地址。 </li><li>ICMP（网际控制报文协议）——网络层协议<br>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文封装在 IP 包中。（ICMP 报文是 IP 层数据报的数据） </li><li>路由选择协议<br>内部网关协议 IGP：RIP，OSPF<br>外部网关协议 EGP：BGP <ol><li>RIP（路由信息协议）——应用层协议<br>基于距离向量的路由选择算法。RIP 用 UDP 用户数据报传送。适合于规模较小的网 络，最大跳数不超过 15。缺点：“好消息传播得快，而坏消息传播得慢”。 仅和相邻路由器交换信息，交换内容为本路由器已知的所有信息（即自己的路由表）。</li><li>OSPF（开放最短路径优先协议）——网络层协议<br>克服 RIP 缺点，对全网拓扑结构采用 Dijikstra 算法求最短路径，但是在路由表中保 存下一条。OSPF 直接用 IP 数据报传送。 和本自治系统中的所有路由器交换信息，内容为周围的相邻路由器的链路状态，采用洪泛法发送信息。 </li><li>BGP（边界网关协议）——应用层协议<br>不同 AS（自治系统）之间的路由协议。用路径向量（path vector）路由协议 BGP 用 TCP 报文传送力求寻找一条能够到达目的网络且比较好的路由。并非要寻找一条最佳路由。 </li></ol></li><li>IGMP（网际组管理协议）<br>多播协议。IGMP 使用 IP 数据报传递其报文。 </li></ol><h3 id="设备-2"><a href="#设备-2" class="headerlink" title="设备"></a>设备</h3><p><strong>路由器</strong></p><p>连接异构网络，完成路由转发，隔离冲突域和广播域，按照 IP 地址转发分组。</p><h2 id="传输层（端到端通信）"><a href="#传输层（端到端通信）" class="headerlink" title="传输层（端到端通信）"></a>传输层（端到端通信）</h2><h3 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h3><p>无连接、不可靠、面向报文。没有拥塞控制。不需要确认。有多路复用和数据检错 功能。 </p><p>注：面向报文是指 UDP 对应用层交下来的报文，不合并，不拆分，只是在其上面 加上首部后就交给了下面的网络层，也就是说无论应用层交给 UDP 多长的报文，它统 统发送，一次发送一个（至于网络层 IP 协议有长度限制要拆分就是 IP 协议的事了） </p><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><p>面向连接、可靠的（数据结果无差错、不丢失、不重复、有序）、全双工通信，有流 量控制（基于滑动窗口）和拥塞控制功能（慢开始和拥塞避免、快重传和快恢复）。提供 单播，不支持广播和多播。面向字节流（即按字节传送）  </p><p>注：TCP 是虚连接的，意思是从进程的角度看两主机之间是逻辑相连的，实际上两 主机采用的是数据报形式传输，并不是虚电路。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol><li>DNS（域名系统）<br>将字母主机名转化为真正的 IP 地址，使用 UPD 传输，端口号为 53。<br>注：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>com 是顶级域名，baidu 是二级域名，www 是三级域名 </li><li>FTP(文件传送协议)<br>基于 TCP，端口号为 21（控制端口）、20（数据端口）。基于 C/S 模式。<br>提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。 和 TFTP 都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文 件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改， 然后再将修改后的文件副本传回到原节点。 </li><li>NFS（网络文件系统）<br>① 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数 据。<br>② NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。<br>③ 在网络上传送的只是少量的修改数据<br>④ 基于 UDP </li><li>TFTP（简单文件传送协议）<br>基于 UDP，需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 </li><li>TELNET（远程终端协议）<br>基于 TCP 连接，端口 23。基于 C/S 方式。<br>①用户通过 TELNET 就可注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。<br>②TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。<br>③通过 NVT 格式实现透明传输（NVT 定义了数据和命令应怎样通过因特网） </li><li>邮件系统 <ol><li>SMTP（简单邮件传输协议）——基于 TCP，端口 25<br> ① 发件人的用户代理向发送方的邮件服务器发送邮件<br> ② 发送方的邮件服务器向接方邮件服务器发送构件 </li><li>MIME（通用因特网邮件扩展）<br> 增加了邮件主体的结构，定义了传输非 ASCII 码的编码规则。 </li><li>POP3（邮局协议）——基于 TCP，端口 110<br> POP 服务器只有再用户输入鉴别信息后，才允许对邮箱进行读取。有“下载并保留” 和“下载并删除”两种工作模式。 </li><li>IMAP（网际报文存取协议）<br> 收信人使用多个用户代理访问同一邮箱，邮件始终保持在邮箱中。加密电子邮件协 议：PGP 与 PEM 协议。 </li></ol></li><li>HTTP（超文本传输协议）<br>HTTP 报文通常都使用 TCP 连接传送，端口 80。是面向文本的，面向事务的 C/S 协 议，是万维网能可靠地交换文件的基础。HTTP 协议由一套从浏览器发往服务器的请求 和一套从服务器发往浏览器的响应组成。 </li></ol><ul><li>URL（统一资源定位符） </li><li>HTML（超文本标记语言） </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点脑图合集</title>
      <link href="/2019/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE%E5%90%88%E9%9B%86/"/>
      <url>/2019/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Sad！</p><a id="more"></a><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p><a href="http://naotu.baidu.com/file/52e459e192994c5571a4a2023c952205?token=77cbf67300f88515" target="_blank" rel="noopener">第1章-操作系统概述</a></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><a href="http://naotu.baidu.com/file/2aff5ab988dccd6d93354764af883bd2?token=7117a82fb9db34d6" target="_blank" rel="noopener">第2章-进程管理</a></p><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>。。</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><a href="http://naotu.baidu.com/" target="_blank" rel="noopener"><strong>support by Baidu naotu</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 考研知识点 </tag>
            
            <tag> 脑图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理知识点脑图合集</title>
      <link href="/2019/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE%E5%90%88%E9%9B%86/"/>
      <url>/2019/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Sad.</p><a id="more"></a><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><p><a href="http://naotu.baidu.com/file/7285668b00f289de70d4cd3fc78d3ee6?token=af7ec7b296a1673e" target="_blank" rel="noopener">第1章-计算机系统概述</a></p><h2 id="数据的表示与运算"><a href="#数据的表示与运算" class="headerlink" title="数据的表示与运算"></a>数据的表示与运算</h2><p><a href="http://naotu.baidu.com/file/f5e19138cc4bf7f792153e0eaedc52df?token=1991029b424dc818" target="_blank" rel="noopener">第2章-数据的表示与运算</a></p><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p><a href="http://naotu.baidu.com/file/031534c7c29114f3070e7c41de650ad8?token=62745216e92b43201" target="_blank" rel="noopener">第3章-存储系统</a></p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p><a href="http://naotu.baidu.com/file/c70e6bc74c441307b0fb731ea5a9c811?token=7388a307aeb4c8e2" target="_blank" rel="noopener">第4章-指令系统</a></p><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><p><a href="http://naotu.baidu.com/file/7691e54245de4e445462b20c4f956ad3?token=51d81e92dc42f05d" target="_blank" rel="noopener">第5章-中央处理器</a></p><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p><a href="http://naotu.baidu.com/file/53187867f5f21549a5339377893e3cd9?token=cae35ab5fc858a9a" target="_blank" rel="noopener">第6章-总线</a></p><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><p><a href="http://naotu.baidu.com/file/7169f003b1b6fc112eba1f28ddc1f9d0?token=99b0036bb404f122" target="_blank" rel="noopener">第7章-输入输出系统</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><a href="http://naotu.baidu.com/" target="_blank" rel="noopener"><strong>support by Baidu naotu</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研知识点 </tag>
            
            <tag> 脑图 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>落水的狗</title>
      <link href="/2019/01/17/%E8%90%BD%E6%B0%B4%E7%9A%84%E7%8B%97/"/>
      <url>/2019/01/17/%E8%90%BD%E6%B0%B4%E7%9A%84%E7%8B%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知轻重的叶，以为熬过了秋风潇潇，就能凌冬傲雪，不过一阵冬雨，凋零水坑。</p></blockquote><p>打击来得太过突然，本应早早料到，却盲目自信。</p><p>打击来的正好，这不过就是我的真实水平罢了。</p><a id="more"></a><p>直到现在我还是不敢相信这是真的。想起当天我的自信的笑容，仿佛冰锥般扎向我的眼睛。</p><p>好不甘心啊。这4个月我到底在做什么？我不明白。</p><p>然而我的确应该明白的。</p><p>我太慢了。磨磨唧唧。我以为我是细致，但是只是脑袋排斥接受知识导致的效率低下罢了。</p><p>我觉得我是喜欢那四门课的。大学三年多，这4门是我为数不多的觉得学起来挺开心的课程。尽管中途遇到了很多问题，但是我都一一解决了不是吗？为什么最大的失望会是你们？这就是我的喜欢的价值吗。。。感觉好嘲讽啊。考前我还那么热心的帮别人解答这4门的问题，真的笑不出来了。</p><blockquote><p>叶落随风散，怨夕追不及。少壮不努力，终将遇此遭。<br>吞牙吃一堑，抖擞复钻研。重启扬帆起，别路花再生。</p></blockquote><p>祝好。</p>]]></content>
      
      
      <categories>
          
          <category> 无言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 牢骚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阴天，在不开灯的房间</title>
      <link href="/2019/01/13/%E9%98%B4%E5%A4%A9%EF%BC%8C%E5%9C%A8%E4%B8%8D%E5%BC%80%E7%81%AF%E7%9A%84%E6%88%BF%E9%97%B4/"/>
      <url>/2019/01/13/%E9%98%B4%E5%A4%A9%EF%BC%8C%E5%9C%A8%E4%B8%8D%E5%BC%80%E7%81%AF%E7%9A%84%E6%88%BF%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>离开一座可以有一百个理由，留恋一座城只因为几个人刻下痕迹。</p></blockquote><p>又是一年冬天，C城的天气依旧很是清爽，没有凌冽的风，也没有冰清的雪，更没有窒息的霾。C城是座挺宜居的城，尽管空气并不如当初那样清澈，但是仍是熟悉的南方山水小镇的样子。</p><a id="more"></a><p>一方水土养一方人，虽然我生于P城，但是C城是我成长的地方，比起生我的P城，我更认同C城为我的故乡。十三年的记忆根植于此，又怎么轻易忘怀？</p><p>但我的的确确是想要忘怀的。想说的太多，戛然笔下。性格所致，表露内心并非我的强项。不过也罢，不过是一场梦就能化解的少年愁，请让我继续保持沉默。</p><p>呵，我果然是个生性薄凉的人。</p><p>罢了罢了，一百个理由和一百零一个理由又有什么区别？</p><p>仅此，记。</p>]]></content>
      
      
      <categories>
          
          <category> 无言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 牢骚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点脑图合集</title>
      <link href="/2018/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE%E5%90%88%E9%9B%86/"/>
      <url>/2018/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Rua！诈尸！</p><p>今天是考研现场确认的日子。。。我觉得我的复习进度太慢了。很难受=。=</p><p>花了近4天才做完考研数据结构的知识点大全（大部分应该是全的），这相当于是我的二轮复习了。。。这一次复习又把上次学会没记住的给过了一遍，感觉又有了一些新的收获。。。</p><p>啊啊啊加快进度！！</p><p>UP！UP！UP！</p><a id="more"></a><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><a href="http://naotu.baidu.com/file/7297029c50efde3919236bc197513085?token=87571b20e55ce156" target="_blank" rel="noopener">第1章-绪论</a></p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><a href="http://naotu.baidu.com/file/7b4bc3f2ea3bb2cd268a884e69646613?token=ac675be50cefaf46" target="_blank" rel="noopener">第2章-线性表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="http://naotu.baidu.com/file/3686b4bbe8bcc845d1c6deaaa2d9cab8?token=d842a5218d006e31" target="_blank" rel="noopener">第3章-栈和队列</a></p><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><p><a href="http://naotu.baidu.com/file/8bbd2c7b4e5cb1a51940a98128aabb94?token=055e6facfe73ae18" target="_blank" rel="noopener">第4章-树和二叉树</a></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><a href="http://naotu.baidu.com/file/7e281825f124a3bbe971c97b5f97772d?token=48c031f9261771f0" target="_blank" rel="noopener">第5章-图</a></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><a href="http://naotu.baidu.com/file/d31c60782c992f9570ad1b6289d9179a?token=649023db451e36e8" target="_blank" rel="noopener">第6章-查找</a></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a href="http://naotu.baidu.com/file/ce5a9d9773a32c6ad3c98ce7c74ba2e1?token=4537fe8c14e78c45" target="_blank" rel="noopener">第7章-排序</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><a href="http://naotu.baidu.com/" target="_blank" rel="noopener"><strong>support by Baidu naotu</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研知识点 </tag>
            
            <tag> 脑图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和C++中的形参传值、指针传值、引用传值解析</title>
      <link href="/2018/09/30/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%82%E4%BC%A0%E5%80%BC%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E5%80%BC%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/09/30/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%82%E4%BC%A0%E5%80%BC%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E5%80%BC%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>咕咕咕咕姑姑。。。。<br>之前的每周刷题被我鸽了两个月了得有了吧。。。其实一个月前还是有在刷的。只是懒得写。这个月以来都在刷考研数学和专业课，因此也就一直咕咕咕带现在了。不过没关系，接下去还是会咕咕咕的，目测也得到考研结束才会回来。。。</p><p>今天突然诈尸是因为，在考研专业课数据结构中，关于函数的指针、引用传值的问题长期以来一直没有解决，今天在题目中遇到了，就干脆一口气弄清楚了，以免下次遇到了再不清不楚。</p><a id="more"></a><h2 id="题引"><a href="#题引" class="headerlink" title="题引"></a>题引</h2><p>刚学c语言的时候肯定都遇到一个最基本的问题，就是函数的数据交换问题，即如何利用参数传递交换两个变量的值。</p><p>关于指针、引用传值的说明，就以这个最简单的例子来做解释。</p><p>为了偷懒，我就不多废话了，请直接看代码注释。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exchange1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-comment">//形参传值，将x的值传给a，y的值传给b，传值之后的所有操作都与x、y无关，就不多解释了 </span><br>  <span class="hljs-keyword">int</span> c = a;<br>  a = b;<br>  b = c;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d,\t&amp;a:%d,\tb:%d,\t&amp;b:%d,\tc:%d,\t&amp;c:%d\n"</span>,a,&amp;a,b,&amp;b,c,&amp;c);<br>&#125;<br><br><span class="hljs-comment">//声明一个指针*p，则有：p是所指向的量的地址，*p是个那个地址所对应的值，&amp;p是p本身所在的地址 </span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exchange2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span></span>&#123;<span class="hljs-comment">//指针传值，将x的地址（&amp;x）传给变量a，y的地址（&amp;y）传给b ，此时*a指向的是&amp;x所对应的值，即为x，*b指向&amp;y所对应的值，即为y </span><br>  <span class="hljs-keyword">int</span> *c = a;<span class="hljs-comment">//新建指针c用于存a值 ，即c现在存了x的地址（&amp;x） </span><br>  a = b;<span class="hljs-comment">//将变量b的值（即y的地址）传递给a ，现在变量a存储的是&amp;y </span><br>  b = c;<span class="hljs-comment">//将变量c的值（即x的地址）传递给b ，因此b现在存的是&amp;x </span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d,\t&amp;a:%d,\tb:%d,\t&amp;b:%d,\tc:%d,\t&amp;c:%d\n"</span>,a,&amp;a,b,&amp;b,c,&amp;c);<span class="hljs-comment">//因此输出分别为：y的地址，a的地址，x的地址，b的地址，x的地址，c的地址 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exchange3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span></span>&#123;<span class="hljs-comment">//指针传值，将x的地址（&amp;x）传给变量a，y的地址（&amp;y）传给b ，此时*a指向的是&amp;x所对应的值，即为x，*b指向&amp;y所对应的值，即为y </span><br>  <span class="hljs-keyword">int</span> c = *a;<span class="hljs-comment">//新建变量c，将指针a所指向的值（x）赋值给c，即现在c = x = 3 </span><br>  a = b;<span class="hljs-comment">//将b中存的y的地址赋值给a，现在a中存的是&amp;y </span><br>  *b = c;<span class="hljs-comment">//将*b所指向的变量重新赋值为c，*b指向的是y，因此本句相当于给y重新赋值为y = c = x = 3 </span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d,\t&amp;a:%d,\tb:%d,\t&amp;b:%d,\tc:%d,\t&amp;c:%d\n"</span>,a,&amp;a,b,&amp;b,c,&amp;c);<span class="hljs-comment">//因此输出分别为： y的地址，a的地址，y的地址，b的地址，x的值（交换前后x的值并没有做改变），c的地址 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exchange4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span></span>&#123;<span class="hljs-comment">//指针传值，将x的地址（&amp;x）传给变量a，y的地址（&amp;y）传给b ，此时*a指向的是&amp;x所对应的值，即为x，*b指向&amp;y所对应的值，即为y </span><br>  <span class="hljs-keyword">int</span> c = *a;<span class="hljs-comment">//新建变量c，将指针a所指向的值（x）赋值给c，即现在c = x = 3  </span><br>  *a = *b;<span class="hljs-comment">//将*a所指向的变量重新赋值为*b所指向的值，也就是将x重新赋值为y的值，也就相当于在主函数中实现x = y </span><br>  *b = c;<span class="hljs-comment">//同样的道理，将*b所指向的变量重新赋值为c，相当于在主函数中实现y = 3； </span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d,\t&amp;a:%d,\tb:%d,\t&amp;b:%d,\tc:%d,\t&amp;c:%d\n"</span>,a,&amp;a,b,&amp;b,c,&amp;c);<span class="hljs-comment">//因此输出分别为： y的地址，a的地址，y的地址，b的地址，c的值（等于交换前x的值），c的地址 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exchange5</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span></span>&#123;<span class="hljs-comment">//引用传值，即a、b实际上并不是实际存在的变量，相当于只是一个标签，当主函数调用这个函数时，会将变量x贴上a的标签，在调用时，因为a只是x的一个别名，因此无论对a做了什么操作，本质上都是对x进行的操作 </span><br>  <span class="hljs-keyword">int</span> c = a;<span class="hljs-comment">//c是函数新声明的变量，并把a的值赋值给c，其实就是把x的值赋值给c </span><br>  a = b;<span class="hljs-comment">//其实就是把y的值赋值给x </span><br>  b = c;<span class="hljs-comment">//其实就是把c的值再赋值给y </span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d,\t&amp;a:%d,\tb:%d,\t&amp;b:%d,\tc:%d,\t&amp;c:%d\n"</span>,a,&amp;a,b,&amp;b,c,&amp;c);<span class="hljs-comment">//因此输出分别为：交换后x的值，x的地址，交换后y的值，y的地址，c的值（等于交换前x的值），c的地址 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"exchange1:\nx:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n"</span>,x,&amp;x,y,&amp;y);<br>  exchange1(x,y);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n\n"</span>,x,&amp;x,y,&amp;y);<br>  <br>  <br>  x = <span class="hljs-number">3</span>; y = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"exchange2:\nx:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n"</span>,x,&amp;x,y,&amp;y);<br>  exchange2(&amp;x,&amp;y);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n\n"</span>,x,&amp;x,y,&amp;y);<br>  <br>  <br>  x = <span class="hljs-number">3</span>; y = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"exchange3:\nx:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n"</span>,x,&amp;x,y,&amp;y);<br>  exchange3(&amp;x,&amp;y);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n\n"</span>,x,&amp;x,y,&amp;y);<br>  <br>  <br>  x = <span class="hljs-number">3</span>; y = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"exchange4:\nx:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n"</span>,x,&amp;x,y,&amp;y);<br>  exchange4(&amp;x,&amp;y);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n\n"</span>,x,&amp;x,y,&amp;y);<br>  <br>  <br>  x = <span class="hljs-number">3</span>; y = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"exchange5:\nx:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n"</span>,x,&amp;x,y,&amp;y);<br>  exchange5(x,y);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"x:%d,\t&amp;x:%d,\ty:%d,\t&amp;y:%d\n\n"</span>,x,&amp;x,y,&amp;y);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>可以自行运行结果做比对看看。<br>参考我的运行结果：</p><figure class="highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C">exchange1:<br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">5</span>,    &amp;y:<span class="hljs-number">6487624</span><br>a:<span class="hljs-number">5</span>,    &amp;a:<span class="hljs-number">6487568</span>,     b:<span class="hljs-number">3</span>,    &amp;b:<span class="hljs-number">6487576</span>,     c:<span class="hljs-number">3</span>,    &amp;c:<span class="hljs-number">6487548</span><br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">5</span>,    &amp;y:<span class="hljs-number">6487624</span><br><br>exchange2:<br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">5</span>,    &amp;y:<span class="hljs-number">6487624</span><br>a:<span class="hljs-number">6487624</span>,      &amp;a:<span class="hljs-number">6487568</span>,     b:<span class="hljs-number">6487628</span>,      &amp;b:<span class="hljs-number">6487576</span>,     c:<span class="hljs-number">6487628</span>,      &amp;c:<span class="hljs-number">6487544</span><br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">5</span>,    &amp;y:<span class="hljs-number">6487624</span><br><br>exchange3:<br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">5</span>,    &amp;y:<span class="hljs-number">6487624</span><br>a:<span class="hljs-number">6487624</span>,      &amp;a:<span class="hljs-number">6487568</span>,     b:<span class="hljs-number">6487624</span>,      &amp;b:<span class="hljs-number">6487576</span>,     c:<span class="hljs-number">3</span>,    &amp;c:<span class="hljs-number">6487548</span><br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">3</span>,    &amp;y:<span class="hljs-number">6487624</span><br><br>exchange4:<br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">5</span>,    &amp;y:<span class="hljs-number">6487624</span><br>a:<span class="hljs-number">6487628</span>,      &amp;a:<span class="hljs-number">6487568</span>,     b:<span class="hljs-number">6487624</span>,      &amp;b:<span class="hljs-number">6487576</span>,     c:<span class="hljs-number">3</span>,    &amp;c:<span class="hljs-number">6487548</span><br>x:<span class="hljs-number">5</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">3</span>,    &amp;y:<span class="hljs-number">6487624</span><br><br>exchange5:<br>x:<span class="hljs-number">3</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">5</span>,    &amp;y:<span class="hljs-number">6487624</span><br>a:<span class="hljs-number">5</span>,    &amp;a:<span class="hljs-number">6487628</span>,     b:<span class="hljs-number">3</span>,    &amp;b:<span class="hljs-number">6487624</span>,     c:<span class="hljs-number">3</span>,    &amp;c:<span class="hljs-number">6487548</span><br>x:<span class="hljs-number">5</span>,    &amp;x:<span class="hljs-number">6487628</span>,     y:<span class="hljs-number">3</span>,    &amp;y:<span class="hljs-number">6487624</span><br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>需要理解的都在注释里说明了。如果有什么说的不对的地方或者有问题的地方欢迎向我提出。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>可供参考的资料：<br><a href="https://blog.csdn.net/yuyaweibest/article/details/63259611" target="_blank" rel="noopener">C语言函数调用三种方式：传值调用，引用调用和传地址调用</a><br><a href="https://blog.csdn.net/tianmaxingkong_/article/details/41593483" target="_blank" rel="noopener">C语言，指针变量的C语言，指针变量的*p,p以及&amp;p的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 引用传值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Week 5</title>
      <link href="/2018/08/12/LeetCode-Week-5/"/>
      <url>/2018/08/12/LeetCode-Week-5/</url>
      
        <content type="html"><![CDATA[<p>正题如下：<br>26.<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener"> 删除排序数组中的重复项 </a><br>27.<a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener"> 移除元素 </a><br>28.<a href="https://leetcode-cn.com/problems/implement-strstr" target="_blank" rel="noopener"> 实现strStr() </a><br>29.<a href="https://leetcode-cn.com/problems/divide-two-integers" target="_blank" rel="noopener"> 两数相除 </a><br>31.<a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener"> 下一个排列 </a><br><a id="more"></a></p><h2 id="Code-26-删除排序数组中的重复项"><a href="#Code-26-删除排序数组中的重复项" class="headerlink" title="Code.26  删除排序数组中的重复项 "></a>Code.26 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener"> 删除排序数组中的重复项 </a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><hr><p><strong>示例</strong><br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>已知数据有序，则双指针遍历数组即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != nums[p]) &#123;<br>                p++;<br>                nums[p] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>大约是76%左右的提交结果，与最优解思路相同，效率还可以优化。</p><h2 id="Code-27-移除元素"><a href="#Code-27-移除元素" class="headerlink" title="Code.27  移除元素 "></a>Code.27 <a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener"> 移除元素 </a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><hr><p><strong>示例</strong><br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>前后双指针，前面遇到val，就从后面调一个非val到前面。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> (nums[<span class="hljs-number">0</span>] == val) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> t = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p &lt; t) &#123;<br>            <span class="hljs-keyword">if</span> (nums[p] == val) &#123;<br>                <span class="hljs-keyword">while</span> (p &lt; t) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[t] != val) &#123;<br>                        nums[p] = nums[t];<br>                        nums[t] = val;<br>                        t--;<br>                        p++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    t--;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[p] != val) &#123;<br>            <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/remove-element/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>同样的算法。。答案非常简洁。。是我太菜了。。</p><h2 id="Code-28-实现strStr"><a href="#Code-28-实现strStr" class="headerlink" title="Code.28  实现strStr() "></a>Code.28 <a href="https://leetcode-cn.com/problems/implement-strstr" target="_blank" rel="noopener"> 实现strStr() </a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>实现Java中的indexOf()</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>字符串比较嘛。。。把字符串拆成字符数组，然后逐一比较匹配。</p><p>Update考研后更新：<br>啊。。这其实要考的是KMP算法吧。。。然而在学习数据结构前写的代码比较不懂事。。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String haystack, String needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (needle.length() &gt; haystack.length() || haystack.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] hayc = haystack.toCharArray();<br>        <span class="hljs-keyword">char</span>[] needc = needle.toCharArray();<br>        <span class="hljs-keyword">int</span> ph = <span class="hljs-number">0</span>, pht = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> pn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len = hayc.length - needc.length;<br>        <span class="hljs-keyword">while</span> (ph &lt;= len) &#123;<br>            <span class="hljs-keyword">if</span> (hayc[ph] == needc[pn]) &#123;<br>                <span class="hljs-keyword">if</span> (needc.length == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> ph;<br>                &#125;<br>                pht = ph;<br>                <span class="hljs-keyword">while</span> (pn &lt; needc.length) &#123;<br>                    <span class="hljs-keyword">if</span> (needc[pn] != hayc[pht]) &#123;<br>                        pn = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    pn++;<br>                    pht++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pn == needc.length) &#123;<br>                    <span class="hljs-keyword">return</span> ph;<br>                &#125;<br>            &#125;<br>            ph++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>魔鬼做法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> haystack.indexOf(needle);<br></code></pre></td></tr></table></figure></p><h2 id="Code-29-两数相除"><a href="#Code-29-两数相除" class="headerlink" title="Code.29  两数相除 "></a>Code.29 <a href="https://leetcode-cn.com/problems/divide-two-integers" target="_blank" rel="noopener"> 两数相除 </a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。<br>返回被除数 dividend 除以除数 divisor 得到的商。</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用了斐波那契数列来作为加速计算个数，避免一个一个计算被除数中有几个除数，在大数计算时有效提高效率。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dividend, <span class="hljs-keyword">int</span> divisor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">long</span> bc = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> bcf = <span class="hljs-keyword">false</span>, cf = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (dividend &lt; <span class="hljs-number">0</span>) &#123;<br>            bc = <span class="hljs-number">0L</span> - (<span class="hljs-keyword">long</span>)dividend;<br>            bcf = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            bc = (<span class="hljs-keyword">long</span>)dividend;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (divisor &lt; <span class="hljs-number">0</span>) &#123;<br>            c = <span class="hljs-number">0L</span> - (<span class="hljs-keyword">long</span>)divisor;<br>            cf = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            c = (<span class="hljs-keyword">long</span>)divisor;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bc &lt; c) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">long</span>[] st = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">50</span>];<span class="hljs-comment">//斐波那契数列50项就有11位， int 类型只有10位</span><br>            <span class="hljs-keyword">long</span>[] ft = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">50</span>];<br>            st[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">long</span>)c;<br>            st[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">long</span>)c;<br>            ft[<span class="hljs-number">0</span>] = <span class="hljs-number">1L</span>;<br>            ft[<span class="hljs-number">1</span>] = <span class="hljs-number">1L</span>;<br>            <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (p &lt; <span class="hljs-number">50</span>) &#123;<span class="hljs-comment">//生成斐波那契数列</span><br>                <span class="hljs-keyword">if</span> (ft[p] &gt;= <span class="hljs-number">1134903170L</span> || st[p] + st[p - <span class="hljs-number">1</span>] &gt; bc) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                p++;<br>                st[p] = st[p - <span class="hljs-number">2</span>] + st[p - <span class="hljs-number">1</span>];<br>                ft[p] = ft[p - <span class="hljs-number">2</span>] + ft[p - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">int</span> pt = p - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">long</span> result = ft[p];<br>            <span class="hljs-keyword">long</span> temp = st[p];<br>            <span class="hljs-keyword">while</span> (pt &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (temp + st[pt] &gt; bc) &#123;<br>                    pt--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    temp += st[pt];<br>                    result += ft[pt];<br>                    <span class="hljs-keyword">if</span> (temp &lt; bc &amp;&amp; temp + st[<span class="hljs-number">0</span>] &gt; bc) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    pt--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">2147483647L</span> &amp;&amp; bcf == cf) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2147483647</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> bcf == cf ? (<span class="hljs-keyword">int</span>)result : (<span class="hljs-keyword">int</span>)(<span class="hljs-number">0L</span> - result);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>最快的老哥们似乎差不多的想法，不过他们用的是二为底的指数计算加速，比我的斐波那契要快一些。并且写的算法也很简洁漂亮。我的做法超过了71%的Java提交记录。</p><h2 id="Code-31-下一个排列"><a href="#Code-31-下一个排列" class="headerlink" title="Code.31  下一个排列 "></a>Code.31 <a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener"> 下一个排列 </a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须原地修改，只允许使用额外常数空间。</p><hr><p><strong>示例</strong><br>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>一步一步分析是不是最大排列，从哪里断掉排列，断掉的地方需要做怎么处理，剩下的就普通的倒序就行了。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> equ = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> f = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//记录哪个地方不是升序序列</span><br>            <span class="hljs-keyword">if</span> (nums[len] &gt; nums[len - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//检测不升序的地方，记录为p</span><br>                <span class="hljs-keyword">if</span> (f) &#123;<br>                    p = len;<br>                    f = <span class="hljs-keyword">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            len--;<br>        &#125;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> nf = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//如果存在不升序，则说明后半部分有更大字典序</span><br>        <span class="hljs-keyword">if</span> (p &gt; len) &#123;<br>            <span class="hljs-keyword">int</span> pt = p;<br>            temp = nums[p - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (pt &lt; nums.length - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">//p后的元素是否是最大排列</span><br>                <span class="hljs-keyword">if</span> (nums[pt + <span class="hljs-number">1</span>] &lt;= nums[p - <span class="hljs-number">1</span>]) &#123;<br>                    nums[p - <span class="hljs-number">1</span>] = nums[pt];<br>                    nums[pt] = temp;<br>                    nf = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                pt++;<br>            &#125;<br>            <span class="hljs-comment">//如果是最大排列就把p前的元素拿来颠倒</span><br>            <span class="hljs-keyword">if</span> (!nf) &#123;<br>                nums[p - <span class="hljs-number">1</span>] = nums[pt];<br>                nums[pt] = temp;<br>            &#125;<br>            <span class="hljs-comment">//剩下直接交换</span><br>            <span class="hljs-keyword">int</span> L = (nums.length - p) / <span class="hljs-number">2</span>;<br>            pt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (pt &lt; L) &#123;<br>                temp = nums[p + pt];<br>                nums[p + pt] = nums[nums.length - <span class="hljs-number">1</span> - pt];<br>                nums[nums.length - <span class="hljs-number">1</span> - pt] = temp;<br>                pt++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//不存在更大，则倒序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length / <span class="hljs-number">2</span>; i++) &#123;<br>                temp = nums[i];<br>                nums[i] = nums[nums.length - <span class="hljs-number">1</span> - i];<br>                nums[nums.length - <span class="hljs-number">1</span> - i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-4"><a href="#参考答案-4" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/next-permutation/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>看答案的动图回非常清晰思路，我就不多说了。</p><h2 id="咕了咕了"><a href="#咕了咕了" class="headerlink" title="咕了咕了"></a>咕了咕了</h2><p>咕咕咕咕咕。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 周记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Week 4</title>
      <link href="/2018/08/05/LeetCode-Week-4/"/>
      <url>/2018/08/05/LeetCode-Week-4/</url>
      
        <content type="html"><![CDATA[<p>本周回了一趟家。由于身份证被我神奇的操作弄丢了。不得已回家补办一下身份证。。现在正在家里躺尸。。<br>本周补上上次的第15题，18题大概可以像15题那么做。但我还没有尝试。<br>23题没有更优化的想法。。因此还不知道怎么做更合适。其他的题目感觉都还比较可以接受。题目如下：<br>15.<a href="https://leetcode-cn.com/problems/3sum/description/" target="_blank" rel="noopener"> 三数之和 </a><br>20.<a href="https://leetcode-cn.com/problems/valid-parentheses/description/" target="_blank" rel="noopener"> 有效的括号 </a><br>21.<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener"> 合并两个有序链表 </a><br>22.<a href="https://leetcode-cn.com/problems/generate-parentheses/description/" target="_blank" rel="noopener"> 括号生成 </a><br>24.<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener"> 两两交换链表中的节点 </a><br><a id="more"></a></p><h2 id="Code-15-三数之和"><a href="#Code-15-三数之和" class="headerlink" title="Code.15  三数之和 "></a>Code.15 <a href="https://leetcode-cn.com/problems/3sum/description/" target="_blank" rel="noopener"> 三数之和 </a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组</p><hr><p><strong>示例</strong><br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先对所给的数组进行从小到大的排序，然后再用三个指针遍历数组。第一个指针p1从第0个数组开始，第二个指针p2和第三个指针p3分别指向p1后一个以及数组最后一个。考虑到数组已经呗排序过了，因此在p1指针不动的情况下，根据<code>p1 + p2 + p3</code>的值判断指针如何移动。如果有和大于目标值，说明p3过大，需要将p3向左移动一位，再判断；如果和小于目标值，说明p2过小，将p2右移；如果等于目标值，则说明找到目标数组。如此反复，直到<code>p2 = p3</code>，说明再给定的p1下已经找全了，则p1右移1位，继续上述步骤。</p><p>题目中要求答案中不包括重复的结果，因此就要再移动的时候判断所以东的下一位是不是跟这一位相同，相同的话就要跳过，继续移位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        Arrays.sort(nums);<span class="hljs-comment">//排序</span><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>;<span class="hljs-comment">//三个指针</span><br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p3 = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[p1] &gt; <span class="hljs-number">0</span> || nums[p3] &lt; <span class="hljs-number">0</span>) &#123;/如果排序后最小值大于<span class="hljs-number">0</span>或者最大值小于<span class="hljs-number">0</span>，说明必定无解（等于<span class="hljs-number">0</span>可能有解）<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">//三个数之和</span><br>        <span class="hljs-keyword">int</span> count = nums.length - <span class="hljs-number">2</span>;<span class="hljs-comment">//p1遍历的次数</span><br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否存在aab型的结果，如果存在则需要考虑acd型，不能直接跳过a</span><br>        <span class="hljs-keyword">int</span> np2 = <span class="hljs-number">0</span>, np3 = <span class="hljs-number">0</span>;<span class="hljs-comment">//临时的指针，用来存p2、p3的重复个数</span><br>        <span class="hljs-keyword">while</span> (p1 &lt; count &amp;&amp; nums[p1] &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//大循环</span><br>            p2 = p1 + <span class="hljs-number">1</span>;<br>            p3 = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (p2 &lt; p3) &#123;<span class="hljs-comment">//小循环</span><br>                result = nums[p1] + nums[p2] + nums[p3];<br>                <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//符合目标值，添加结果</span><br>                    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();<br>                    res.add(nums[p1]);<br>                    res.add(nums[p2]);<br>                    res.add(nums[p3]);<br>                    list.add(res);<br>                    flag = nums[p1] == nums[p2] ? <span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span>;<span class="hljs-comment">//判断是否为aab型</span><br>                    np2 = p2 + <span class="hljs-number">1</span>;<br>                    np3 = p3 - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> (np2 &lt; np3) &#123;<span class="hljs-comment">//找p2、p3重复了几次</span><br>                        <span class="hljs-keyword">if</span> (nums[np2] == nums[p2]) &#123;<br>                            np2++;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (nums[np3] == nums[p3]) &#123;<br>                            np3--;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (nums[np2] != nums[p2] &amp;&amp; nums[np3] != nums[p3]) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    p2 = np2;<br>                    p3 = np3;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果结果大了</span><br>                    p3--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//结果小了</span><br>                    p2++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[p1] != nums[p1 + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//p1没有重复的话</span><br>                p1++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//p1有重复</span><br>                <span class="hljs-keyword">int</span> t = p1 + <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">while</span> (nums[p1] == nums[t] &amp;&amp; t &lt;= count) &#123;<span class="hljs-comment">//判断重复了几个</span><br>                    t++;<br>                &#125;<br>                p1 = flag ? t : t - <span class="hljs-number">1</span>;<span class="hljs-comment">//如果是aab型，就多移动一位</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>大约是76%左右的提交结果，还有一些细节可以优化。</p><h2 id="Code-20-有效的括号"><a href="#Code-20-有效的括号" class="headerlink" title="Code.20  有效的括号 "></a>Code.20 <a href="https://leetcode-cn.com/problems/valid-parentheses/description/" target="_blank" rel="noopener"> 有效的括号 </a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>·左括号必须用相同类型的右括号闭合。<br>·左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><hr><p><strong>示例</strong><br>输入: “()[]{}”<br>输出: true</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>想到的方法就是用堆栈。把输入的括号依次压入堆栈，如果能匹配成一对，就弹出，如果最后堆栈内为空，那么说明这串括号是匹配的，否则就是不匹配的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//长度为0，返回真</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//奇数长度返回假</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] sc = s.toCharArray();<span class="hljs-comment">//字符串转为数组</span><br>        stack temp = <span class="hljs-keyword">new</span> stack(<span class="hljs-string">'a'</span>);<span class="hljs-comment">//新建堆栈，给堆栈放入一个无关的开头</span><br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (p &lt; len) &#123;<br>            temp = temp.push(sc[p]);<span class="hljs-comment">//依次压入堆栈</span><br>            p++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp.c != <span class="hljs-string">'a'</span>) &#123;<span class="hljs-comment">//如果不是初始字符，说明匹配失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span> </span>&#123;<span class="hljs-comment">//双向链表做堆栈</span><br>    <span class="hljs-keyword">char</span> c;<br>    stack next;<span class="hljs-comment">//下一个堆栈</span><br>    stack pre;<span class="hljs-comment">//上一个堆栈</span><br>    stack(<span class="hljs-keyword">char</span> a) &#123;<span class="hljs-comment">//构造方法</span><br>        c = a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> stack <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a)</span> </span>&#123;<span class="hljs-comment">//压入堆栈</span><br>            <span class="hljs-keyword">if</span> (a == <span class="hljs-string">')'</span>) &#123;<span class="hljs-comment">//如果是压入后括号</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.c == <span class="hljs-string">'('</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pre != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果前一个不为空返回前一个，否则返回空。考虑的是第一个没有前一个。实际上必不为空，因为我放了一个无关的a作为开头，a必定不会被消除。</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pre;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-string">']'</span>) &#123;<span class="hljs-comment">//同理了</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.c == <span class="hljs-string">'['</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pre != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pre;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-string">'&#125;'</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.c == <span class="hljs-string">'&#123;'</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pre != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pre;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;<br>            stack temp = <span class="hljs-keyword">new</span> stack(a);<span class="hljs-comment">//如果压入的没有消除，就新建一个元素，指针指向新建的元素</span><br>            temp.pre = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">this</span>.next = temp;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.next;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>暂时没有官方答案。我这个做法，虽然思路是没什么错，就是做法相当于绕了一个圈。因为这个“堆栈”实际上用列表就能很完美的实现啊。用一个指针指向元素，利用元素的左移模拟弹出，右移模拟压入，写起来整个程序更简洁，不像我这自己创建了一个双向链表的类，就麻烦很多了= =。不过倒是让我回顾了类的写法。。</p><p>至于用列表实现的代码，我就不写了。。</p><h2 id="Code-21-合并两个有序链表"><a href="#Code-21-合并两个有序链表" class="headerlink" title="Code.21  合并两个有序链表 "></a>Code.21 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener"> 合并两个有序链表 </a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><hr><p><strong>示例</strong><br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>链表已经有序了。所以做法就用两个指针分别遍历，然后取出小数放进新的链表中。如果有一个空了，就把另一个剩下的加入结果链表就行。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode(int x) &#123; val = x; &#125;<br> * &#125;<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果有一个为空，返回另一个</span><br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<span class="hljs-comment">//结果链表</span><br>        ListNode p1 = l1, p2 = l2, p3 = res;<span class="hljs-comment">//辅助指针</span><br>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-keyword">null</span> &amp;&amp; p2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1.val &lt; p2.val) &#123;<span class="hljs-comment">//如果第一个比第二个小</span><br>                p3.val = p1.val;<br>                <span class="hljs-keyword">if</span> (p1.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//判断第一个是否为最后一个了，是的话就把剩下的接到最后</span><br>                    p3.next = p2;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p1 = p1.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//跟上面一样</span><br>                p3.val = p2.val;<br>                <span class="hljs-keyword">if</span> (p2.next == <span class="hljs-keyword">null</span>) &#123;<br>                    p3.next = p1;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p2 = p2.next;<br>                &#125;<br>            &#125;<br>            p3.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>            p3 = p3.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>暂无官方解答。我的提交执行用时<br>超过 82.29 % 的 java 提交记录。</p><h2 id="Code-22-括号生成"><a href="#Code-22-括号生成" class="headerlink" title="Code.22  括号生成 "></a>Code.22 <a href="https://leetcode-cn.com/problems/generate-parentheses/description/" target="_blank" rel="noopener"> 括号生成 </a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><hr><p><strong>示例</strong><br>例如，给出 n = 3，生成结果为：<br>[“((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题一开始没有思路不会写。当时答案还没有出来。大概是两周之后，出了答案，我看了一下，就看懂了回溯法。其根本在于要始终保持放入括号后的序列的有效性。要保持有效性，关键有两点：<br>1、当序列中左括号数量小于右括号时，序列还可以放入两种括号中的一种；当序列中左右括号数量相同时，只能放入左括号。<br>2、左右括号的总数量各为n时，把结果序列加入列表。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<span class="hljs-comment">//结果列表</span><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果n不是正数，返回空列表</span><br>            list.add(<span class="hljs-string">""</span>);<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        String str = <span class="hljs-string">"("</span>;<span class="hljs-comment">//先放入第一个左括号</span><br>        addBracket(list, n - <span class="hljs-number">1</span>, n, str);<span class="hljs-comment">//深度优先循环</span><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBracket</span><span class="hljs-params">(List&lt;String&gt; list, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, String str)</span> </span>&#123;<span class="hljs-comment">//left、right分别为剩余量，str为当前的序列</span><br>        <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果剩余量小于0，结束</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) &#123;<br>                list.add(str);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                addBracket(list, left - <span class="hljs-number">1</span>, right, str + <span class="hljs-string">"("</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            addBracket(list, left - <span class="hljs-number">1</span>, right, str + <span class="hljs-string">"("</span>);<br>            <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>                addBracket(list, left, right - <span class="hljs-number">1</span>, str + <span class="hljs-string">")"</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>暴力法就不谈了。回朔法跟我上面的做法思路一致，就是答案更加简练更厉害。简单聊一下闭合数做法。<br>一开始我的想法差不多，序列最基本的元素一对<code>()</code>，利用括号的互相嵌套以及排列组合成一个长序列。假设初始序列已经有一对括号了，那么对这对序列添加一对括号，可以添加的地方只有两个，一个是括号之中，一个是括号外面，即原序列的左右两边。为了方便讨论，我们就只考虑放在右边（因为放左边一样）。</p><p>上面这是闭合数法最基本的思想。闭合数就是反过来思考，如果已经有一个长度为<code>2 * c</code>的匹配括号序列A，又有一个一个长度为<code>2 * (n - 1 - c)</code>的匹配括号序列B，那么要将A、B、和一对新括号复合成一个长度为2n的新的序列，一共有如下两类做法：<br>1、(A)B / B(A) / (B)A / A(B)，即序列在括号内<br>2、()AB / ()BA / A()B / B()A / AB() / BA()，即序列在括号外</p><p>上面这些做法中可能会有重复，但是重复的情况如何我们没有办法判断，只能根据具体的括号序列才能做判断。</p><p>但是，如果考虑的是，序列集合A中的序列都是长度不超过2c的所有符合要求的序列，序列集合B中的序列都是长度长度不超过2(n-1-c)的所有符合要求的序列，先假设<code>c&lt;(n-1-c)</code>，那么由于集合A与集合B都是符合要求的所有序列的集合，因此无论是上面中的哪一种，都会被<code>(A)B</code>这种情况所囊括。</p><p>因此我们就可以得到一个递归关系，c为0时，必有集合A为<code>&quot;&quot;</code>,集合B为长度不超过<code>2n-2</code>的序列集合；c为1时，集合A为<code>()</code>，集合B为长度不超过<code>2n-4</code>的序列集合；c为2时，集合A为<code>()(),(())</code>，集合B为长度不超过<code>2n-6</code>的序列集合······依次按照<code>(A)B</code>组合即可得到所有结果。</p><p>这个方法比较难考虑。。反正我自己肯定想不到。。</p><h2 id="Code-24-两两交换链表中的节点"><a href="#Code-24-两两交换链表中的节点" class="headerlink" title="Code.24  两两交换链表中的节点 "></a>Code.24 <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener"> 两两交换链表中的节点 </a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br><strong>说明:</strong><br>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><hr><p><strong>示例</strong><br>输入1-&gt;2-&gt;3-&gt;4, 输出 2-&gt;1-&gt;4-&gt;3.</p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接法不解释。。。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode(int x) &#123; val = x; &#125;<br> * &#125;<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//如果长度小于1，直接返回就行</span><br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode res = head, temp, temp2, temp3;<span class="hljs-comment">//辅助的指针，用于记录交换的两个节点的位置</span><br>        temp = res.next;<br>        res.next = temp.next;<br>        temp.next = res;<br>        res = temp;<br>        temp = temp.next;<br>        <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span> &amp;&amp; temp.next.next != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//保证必有两个节点才能交换</span><br>            temp2 = temp.next;<span class="hljs-comment">//链表交换需要注意不要把下一个节点给弄丢了</span><br>            temp3 = temp2.next;<br>            temp.next = temp3;<br>            temp2.next = temp3.next;<br>            temp3.next = temp2;<br>            temp = temp2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-4"><a href="#参考答案-4" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>暂时没有。我的提交执行用时已经战胜 99.78 % 的 java 提交记录。</p><p>这题非常基础，考的是链表交换的步骤。。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本周就这样吧。。<br>愿世界和平。。<br>咕咕咕咕.jpg</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 周记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Week 3</title>
      <link href="/2018/07/29/LeetCode-Week-3/"/>
      <url>/2018/07/29/LeetCode-Week-3/</url>
      
        <content type="html"><![CDATA[<p>本周的学习效率好低，感觉整个人就很浮躁。好烦啊。优秀的人各有各的优秀，咸鱼的人只有各种废渣的理由。。= =</p><p>本周照常更新第12、13、14，16、17以及19题，题目分别是：</p><p>12.<a href="https://leetcode-cn.com/problems/integer-to-roman/description/" target="_blank" rel="noopener"> 整数转罗马数字 </a><br>13.<a href="https://leetcode-cn.com/problems/roman-to-integer/description/" target="_blank" rel="noopener"> 罗马数字转整数 </a><br>14.<a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener"> 最长公共前缀 </a><br>16.<a href="https://leetcode-cn.com/problems/3sum-closest/description/" target="_blank" rel="noopener"> 最接近的三数之和 </a><br>17.<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener"> 电话号码的字母组合 </a><br>19.<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener"> 删除链表的倒数第N个节点 </a><br><a id="more"></a></p><p>另外有一个对我来说不太好的消息。考研中的数据结构解题只能用C或者C++求解。。对C和C++我基本都不太记得了。可能C还会一点，C++当初学的时候根本没好好学过只会用当时大一学的C的语法加上半吊子的类。</p><p>我个人其实不是太喜欢C++，主要的原因是C++比Java更接近底层一些，毕竟是C上面传下来的。然后它对于指针之类的操作就更灵活一点。我还是喜欢Java以及觉得Java比C++优雅的很重要的一个原因就是不用纠结指针的问题了。。之前写过一个C/C++的扫雷小游戏（下次有机会我弄上来），里头的指针弄得我很烦。其实也没有用到很复杂的指针，但就是不是很清楚具体是什么。。结果稀里糊涂最后居然能成功运行。。</p><p>所以话说回来，可能接下去会改用C或者C++来刷题了。。我倒是觉得思想比较重要。但是要是到时候写不出来C/C++，还是会有点尴尬。。不过我已经刷了20多道题了。。这些题还都是用Java写的。回头尝试用C再实现一次应该不难？回头再说。。先更新本周的题。。Come on！</p><h2 id="Code-12-整数转罗马数字"><a href="#Code-12-整数转罗马数字" class="headerlink" title="Code.12  整数转罗马数字 "></a>Code.12 <a href="https://leetcode-cn.com/problems/integer-to-roman/description/" target="_blank" rel="noopener"> 整数转罗马数字 </a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><hr><p><strong>示例</strong><br>输入: 58<br>输出: “LVIII”<br>解释: C = 100, L = 50, XXX = 30, III = 3.</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将输入的数按照其位数拆解成数组，再将每一个数转化为对应的罗马数字。由于罗马数字在个位上有两位字符可以表示，在十位、百位上也有各两位可以表示，在千位上由于输入限制到3k，因此千位只有1位。这样子我们可以先将罗马数字字符弄成一个字符数组，在数字的第<code>i</code>位上，可以直接取字符的第<code>2i</code>、<code>2i+1</code>以及<code>2(i + 1)</code>(如果有9的话需要从上一级借位)字符组成对应的数字。这样就统一了每一位的输入，就不用针对每一位单独讨论了。</p><p>另外有一点就是从最高位开始转化，符合从左到右的习惯，而且输出的结果也很好理解。如果从低位开始的话，有借位的情况就稍微麻烦一点。也并不是没有办法解决，我这里就不展开讨论了，直接上代码。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1</span> || num &gt; <span class="hljs-number">3999</span>) &#123;<span class="hljs-comment">//当输入的数越界，返回空。题目说了范围，不要这个也可以</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> wei = <span class="hljs-number">0</span>;<span class="hljs-comment">//从个位开始获取</span><br>        <span class="hljs-keyword">int</span> temp = num;<br>        <span class="hljs-keyword">int</span>[] number = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<span class="hljs-comment">//题目最多到千位，只要4位就行</span><br>        <span class="hljs-keyword">while</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//依次获取个位、十位、百位、千位</span><br>            number[wei] = temp % <span class="hljs-number">10</span>;<br>            temp /= <span class="hljs-number">10</span>;<br>            wei++;<br>        &#125;<br>        String result = <span class="hljs-string">""</span>;<span class="hljs-comment">//结果</span><br>        <span class="hljs-keyword">while</span> (wei &gt; <span class="hljs-number">0</span>) &#123;<br>            wei--;<span class="hljs-comment">//从最高位开始转化</span><br>            result += numToRoman(number[wei], wei);<span class="hljs-comment">//转化函数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">numToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> wei)</span> </span>&#123;<span class="hljs-comment">//转化函数，num代表这某个位上的数，wei代表它所在的位</span><br>        <span class="hljs-keyword">int</span> one = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span>[] letter = &#123;<span class="hljs-string">'I'</span>,<span class="hljs-string">'V'</span>,<span class="hljs-string">'X'</span>,<span class="hljs-string">'L'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'M'</span>&#125;;<span class="hljs-comment">//转化字典</span><br>        String str = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">4</span>) &#123;<span class="hljs-comment">//1-3直接输出1或者10或者100</span><br>            one = num;<br>            <span class="hljs-keyword">while</span> (one &gt; <span class="hljs-number">0</span>) &#123;<br>                str += letter[wei * <span class="hljs-number">2</span>];<br>                one--;<br>            &#125;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">4</span>) &#123;<span class="hljs-comment">//如果为4的话，需要转化为5-1</span><br>            <span class="hljs-keyword">return</span> str + letter[wei * <span class="hljs-number">2</span>] + letter[wei * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">5</span>) &#123;<span class="hljs-comment">//5有单独的数字</span><br>            <span class="hljs-keyword">return</span> str + letter[wei * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">5</span> &amp;&amp; num &lt; <span class="hljs-number">9</span>) &#123;<span class="hljs-comment">//6-8用5+（num - 5）* 1</span><br>            one = num - <span class="hljs-number">5</span>;<br>            str += letter[wei * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (one &gt; <span class="hljs-number">0</span>) &#123;<br>                str += letter[wei * <span class="hljs-number">2</span>];<br>                one--;<br>            &#125;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果为9的话，就借位，用10-1</span><br>            <span class="hljs-keyword">return</span> str + letter[wei * <span class="hljs-number">2</span>] + letter[wei * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>暂时没有答案，这个解法在排行中速度超过了78.9%的Java提交记录，所以说这个算法还算较为合格。一次提交就通过，真开心~</p><h2 id="Code-13-罗马数字转整数"><a href="#Code-13-罗马数字转整数" class="headerlink" title="Code.13  罗马数字转整数 "></a>Code.13 <a href="https://leetcode-cn.com/problems/roman-to-integer/description/" target="_blank" rel="noopener"> 罗马数字转整数 </a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><hr><p><strong>示例</strong><br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实就是上一题反过来操作。。依次读取字符，暗战转化规则转成数字，然后再合成一个数字。</p><p>这题没有想太多。直接暴力解题了。主要是考虑到藩镇都要字符匹配，合在一起跟分开似乎区别不是很大？从算法简洁的角度来说。。这么做显然是不太合格的。。但是我还真没有什么解决的想法（字符映射成数字？）。。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<span class="hljs-comment">//转成字符数组来处理</span><br>        <span class="hljs-keyword">int</span> p = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] num = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//用来存每一位数字的</span><br>        <span class="hljs-keyword">while</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//个位</span><br>            <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'I'</span>) &#123;<br>                num[<span class="hljs-number">0</span>]++;<span class="hljs-comment">//如果是1的话，就在个位的对应位上+1</span><br>                p--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'V'</span>) &#123;<span class="hljs-comment">//如果是5的话，就在个位上+5</span><br>                num[<span class="hljs-number">0</span>] += <span class="hljs-number">5</span>;<br>                p--;<br>                <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果5的前面还有数字，说明是4，那就个位减1</span><br>                    <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'I'</span>) &#123;<br>                        num[<span class="hljs-number">0</span>]--;<br>                        p--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//十位</span><br>            <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'X'</span>) &#123;<span class="hljs-comment">//如果是10，十位+1</span><br>                num[<span class="hljs-number">1</span>]++;<br>                p--;<br>                <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果十位的前面有一个1，说明是借位的。。借了一个1，因此在个位上减1就行了</span><br>                    <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'I'</span>) &#123;<br>                        num[<span class="hljs-number">0</span>]--;<br>                        p--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'L'</span>) &#123;<span class="hljs-comment">//50，所以十位上+5</span><br>                num[<span class="hljs-number">1</span>] += <span class="hljs-number">5</span>;<br>                p--;<br>                <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//40，所以十位-1</span><br>                    <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'X'</span>) &#123;<br>                        num[<span class="hljs-number">1</span>]--;<br>                        p--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//百位跟10位一样</span><br>            <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'C'</span>) &#123;<br>                num[<span class="hljs-number">2</span>]++;<br>                p--;<br>                <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'X'</span>) &#123;<br>                        num[<span class="hljs-number">1</span>]--;<br>                        p--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'D'</span>) &#123;<br>                num[<span class="hljs-number">2</span>] += <span class="hljs-number">5</span>;<br>                p--;<br>                <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'C'</span>) &#123;<br>                        num[<span class="hljs-number">2</span>]--;<br>                        p--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//千位只有1的可能，就简单一点</span><br>            <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'M'</span>) &#123;<br>                num[<span class="hljs-number">3</span>]++;<br>                p--;<br>                <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (str[p] == <span class="hljs-string">'C'</span>) &#123;<br>                        num[<span class="hljs-number">2</span>]--;<br>                        p--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num[<span class="hljs-number">0</span>] + num[<span class="hljs-number">1</span>] * <span class="hljs-number">10</span> + num[<span class="hljs-number">2</span>] * <span class="hljs-number">100</span> + num[<span class="hljs-number">3</span>] * <span class="hljs-number">1000</span>;<span class="hljs-comment">//把各个位上的数字乘位权然后加起来就行了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>暂时也没有答案。这个提交了大约战胜了57.8%的java提交。。算是常规的做法吧。</p><h2 id="Code-14-最长公共前缀"><a href="#Code-14-最长公共前缀" class="headerlink" title="Code.14  最长公共前缀 "></a>Code.14 <a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener"> 最长公共前缀 </a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”</p><hr><p><strong>示例</strong><br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>双重循环，第一个循环遍历最短的字符串的各个字符，第二个循环判断其余字符串的第i个字符是不是这个字符，不是的话直接返回最短字符串的从头到第<code>i-1</code>个字符串。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果为空数组，直接返回空</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//如果只有一个字符串，直接返回它本身</span><br>            <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] len = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[strs.length];<span class="hljs-comment">//计算字符串内所有字符串的长度</span><br>        <span class="hljs-keyword">int</span> min = <span class="hljs-number">0</span>;<span class="hljs-comment">//最小字符串长度所在位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<span class="hljs-comment">//找出字符串最短的那个字符串</span><br>            len[i] = strs[i].length();<br>            min = len[min] &lt; strs[i].length() ? min : i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len[min] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果最短字符串为空，就直接返回空字符串</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>            findout:<span class="hljs-comment">//给大循环命名为findout</span><br>            <span class="hljs-keyword">while</span> (p &lt; len[min]) &#123;<span class="hljs-comment">//每个字符串都查找一次</span><br>                <span class="hljs-keyword">int</span> ps = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (ps &lt; strs.length) &#123;<span class="hljs-comment">//判断对应位置的是否相同</span><br>                    <span class="hljs-keyword">if</span> (strs[min].charAt(p) != strs[ps].charAt(p)) &#123;<br>                        <span class="hljs-keyword">break</span> findout;<span class="hljs-comment">//不同的话直接退出大循环，可以直接返回结果了</span><br>                    &#125;<br>                    ps++;<br>                &#125;<br>                p++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> strs[min].substring(<span class="hljs-number">0</span>, p);<span class="hljs-comment">//直接返回最短字符串的从0到p-1的字符串</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>这个也没有答案。本次提交战胜了86%的java提交记录。emmm毕竟是一道简单题。。解题思路大家估计都差不多。。。吧？</p><h2 id="Code-16-最接近的三数之和"><a href="#Code-16-最接近的三数之和" class="headerlink" title="Code.16  最接近的三数之和 "></a>Code.16 <a href="https://leetcode-cn.com/problems/3sum-closest/description/" target="_blank" rel="noopener"> 最接近的三数之和 </a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><hr><p><strong>示例</strong><br>nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到这道题，第一个想法就是暴力大循环求解。。。想了很久并没有优化的方法。。按道理这个应该用什么诡异的数据结构能够优化。。我甚至还想到了排序，然后双指针。。但是这种算法显然效率还不如大循环。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt; nums.length; k++) &#123;<br>                    sum = nums[i] + nums[j] + nums[k];<br>                    <span class="hljs-keyword">if</span> (min &gt; Math.abs(target - sum)) &#123;<br>                        min = Math.abs(target - sum);<br>                        result = sum;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>先排序再找数的效率真的不如大循环吗？</p><p>并不！！刚说完这句话我就打脸了。好气啊。。参考了一下网上别人的做法，就是先排序了，然后再找的。。我是真的没有想到这样的算法居然会比大循环来的快。。</p><p>不过从时间复杂度的角度来看，大循环是<code>O(n^3)</code>，先排序后找的时间复杂度是:排序的时间<code>O(n^2)</code> + 找相近的值的效率<code>O(n^2)</code> = 总时间<code>2 * O(n^2)</code> = <code>O(n^2)</code> ，因此理论上比大循环要快的。</p><p>这个故事告诉我们，想到什么算法还是要冷静分析，不能光靠猜想。。。</p><p>附上别人的做法：<br><a href="https://www.cnblogs.com/jimmycheng/p/7159535.html" target="_blank" rel="noopener">LeetCode 16. 3Sum Closest. （最接近的三数之和）——by几米空间</a></p><h2 id="Code-17-电话号码的字母组合"><a href="#Code-17-电话号码的字母组合" class="headerlink" title="Code.17  电话号码的字母组合 "></a>Code.17 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener"> 电话号码的字母组合 </a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><hr><p><strong>示例</strong><br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题我用了树的思想来解题。因为一个数字对应多种情况，需要分开来讨论，并且数字与数字之间还有继承的关系，因此用树的结构来处理是最合适的。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>        digits = digits.trim();<span class="hljs-comment">//先把字符串前面的空格去掉</span><br>        <span class="hljs-keyword">int</span> len = digits.length();<span class="hljs-comment">//给定长度</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//长度为空直接返回空</span><br>            List&lt;String&gt; empty = Arrays.asList();<br>            <span class="hljs-keyword">return</span> empty ;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] dig = digits.toCharArray();<span class="hljs-comment">//把字符串拆成数组</span><br>        strTree.dig = dig;<span class="hljs-comment">//赋值树类的静态变量</span><br>        strTree.len = dig.length;<br>        strTree getStr = <span class="hljs-keyword">new</span> strTree();<span class="hljs-comment">//新建树</span><br>        getStr.addKid();<span class="hljs-comment">//一键添加子节点</span><br>        List&lt;String&gt; result =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(strTree.res);<br>        strTree.res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//LeetCode的评测机处理静态变量如果不手动清空会出错。一开始不知道，坑了我几次提交记录，气死我了！！！</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">strTree</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<span class="hljs-comment">//这几个静态变量都是辅助用的</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] letter = <span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span>.toCharArray();<span class="hljs-comment">//字母表</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] dig;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> len;<br>    String str;<br>    <span class="hljs-keyword">int</span> order;<br>    strTree parent;<br>    strTree kid1, kid2, kid3, kid4;<span class="hljs-comment">//最多可以有4各分支，故声明4个孩子</span><br>    strTree() &#123;<span class="hljs-comment">//默认构造函数，用来初始化根节点的</span><br>        order = <span class="hljs-number">0</span>;<br>        str = <span class="hljs-string">""</span>;<br>        parent = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    strTree(<span class="hljs-keyword">char</span> a, strTree p) &#123;<span class="hljs-comment">//构造函数，用来生成子节点的</span><br>        <span class="hljs-keyword">this</span>.parent = p;<br>        <span class="hljs-keyword">this</span>.order = parent.order + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.str = parent.str + a;<span class="hljs-comment">//把父节点的字符串继承下来并添加上自己的内容</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addKid</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//虽然命名成添加节点，但是其实是一键生成树函数，毕竟自己调用自己就可以不断生成子节点的子节点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.order == strTree.len) &#123;如果到最后一个数字了，就是叶节点，不用再添加子节点了，就把这个叶节点添加进结果列表里去就行<br>            strTree.res.add(<span class="hljs-keyword">this</span>.str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dig[order] == <span class="hljs-string">'7'</span>) &#123;<span class="hljs-comment">//下面7、8、9数字比较特殊，所以得单独拿出来讨论</span><br>            kid1 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'p'</span>, <span class="hljs-keyword">this</span>);<br>            kid1.addKid();<br>            kid2 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'q'</span>, <span class="hljs-keyword">this</span>);<br>            kid2.addKid();<br>            kid3 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'r'</span>, <span class="hljs-keyword">this</span>);<br>            kid3.addKid();<br>            kid4 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'s'</span>, <span class="hljs-keyword">this</span>);<br>            kid4.addKid();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dig[order] == <span class="hljs-string">'8'</span>) &#123;<br>            kid1 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'t'</span>, <span class="hljs-keyword">this</span>);<br>            kid1.addKid();<br>            kid2 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'u'</span>, <span class="hljs-keyword">this</span>);<br>            kid2.addKid();<br>            kid3 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'v'</span>, <span class="hljs-keyword">this</span>);<br>            kid3.addKid();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dig[order] == <span class="hljs-string">'9'</span>) &#123;<br>            kid1 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'w'</span>, <span class="hljs-keyword">this</span>);<br>            kid1.addKid();<br>            kid2 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'x'</span>, <span class="hljs-keyword">this</span>);<br>            kid2.addKid();<br>            kid3 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'y'</span>, <span class="hljs-keyword">this</span>);<br>            kid3.addKid();<br>            kid4 = <span class="hljs-keyword">new</span> strTree(<span class="hljs-string">'z'</span>, <span class="hljs-keyword">this</span>);<br>            kid4.addKid();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//剩下的就一样处理就行</span><br>            kid1 = <span class="hljs-keyword">new</span> strTree(letter[(<span class="hljs-keyword">this</span>.dig[order] - <span class="hljs-number">50</span>) * <span class="hljs-number">3</span>], <span class="hljs-keyword">this</span>);<br>            kid1.addKid();<br>            kid2 = <span class="hljs-keyword">new</span> strTree(letter[(<span class="hljs-keyword">this</span>.dig[order] - <span class="hljs-number">50</span>) * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>);<br>            kid2.addKid();<br>            kid3 = <span class="hljs-keyword">new</span> strTree(letter[(<span class="hljs-keyword">this</span>.dig[order] - <span class="hljs-number">50</span>) * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>);<br>            kid3.addKid();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-4"><a href="#参考答案-4" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>没有参考答案。这题战胜了95.76%的Java提交记录，还是比较好的。。不过其他人的时间也基本上没有差别特别多。。估计大家都用的差不多的做法，只是细节的部分有不同罢了。</p><h2 id="Code-19-删除链表的倒数第N个节点"><a href="#Code-19-删除链表的倒数第N个节点" class="headerlink" title="Code.19  删除链表的倒数第N个节点 "></a>Code.19 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener"> 删除链表的倒数第N个节点 </a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><hr><p><strong>示例</strong><br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>解题的时候没多想，用的是二次遍历的方式，第一次遍历出列表的个数，第二次遍历到需要删除的地方，把节点删除。</p><p>做完题后来也没有看答案。只是在刷后面的题的时候，突然想起来，这种题其实一遍遍历就够了。虽然标记是难题，但实际上这题也不难，后来就没有改。具体做法还是看下面的参考答案。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode(int x) &#123; val = x; &#125;<br> * &#125;<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        ListNode temp = head;<br>        ListNode temp2 = head;<br>        <span class="hljs-keyword">int</span> size = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//遍历链表的长度</span><br>            size++;<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == size) &#123;<span class="hljs-comment">//如果删头</span><br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否者删中间或结尾</span><br>            temp = head;<br>            <span class="hljs-keyword">int</span> i = size;<br>            <span class="hljs-keyword">while</span> (i - n &gt; <span class="hljs-number">0</span>) &#123;<br>                temp2 = temp;<br>                temp = temp.next;<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>                temp2.next = <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp2.next = temp.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-5"><a href="#参考答案-5" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>双指针，既然要删除倒数第i个，那就让第一个指针先遍历i个，然后第二个指针再出发。当第一个指针指到结尾的时候，将第二个指针指向的节点的下一个删除就行了。具体的做法请看参考答案，答案有配图，比较详细。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这周就先这样更新6道题吧。中间跳过去的两道题，大概有了一点思路。应该会在下周补上吧。</p><p>写代码还是比学数学还玩一点点。。不过任务还有很多。不止有数学，还有其他各科目等着我。。</p><blockquote><p><strong>微笑面对危险 🎵<br>梦想成真不会遥远 🎵<br>鼓起勇气坚定向前 🎵<br>奇迹一定会出现 🎵</strong></p></blockquote><p>😐see you next week！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 周记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Week 2</title>
      <link href="/2018/07/22/LeetCode-Week-2/"/>
      <url>/2018/07/22/LeetCode-Week-2/</url>
      
        <content type="html"><![CDATA[<p>复习高数要死了。。考研真难！！<br>填上本周的坑。本期主要回顾LeetCode题库中的6-9题还有第11题。也就是<a href="https://leetcode-cn.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener"> Z字形变换 </a>、<a href="https://leetcode-cn.com/problems/reverse-integer/description/" target="_blank" rel="noopener"> 反转整数 </a>、<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/description/" target="_blank" rel="noopener"> 字符串转整数 (atoi) </a>、<a href="https://leetcode-cn.com/problems/palindrome-number/description/" target="_blank" rel="noopener"> 回文数 </a>和<a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener"> 盛最多水的容器 </a>这五题。第5题上次没有看懂，到现在也还没研究。。第10题，是真的不会做。情况有点复杂。一时还没整理清楚怎么处理不会有遗漏。。Whatever，先看着填坑吧。。<del>林克死大头</del><br><a id="more"></a></p><h2 id="Code-6-Z字形变换"><a href="#Code-6-Z字形变换" class="headerlink" title="Code.6  Z字形变换 "></a>Code.6 <a href="https://leetcode-cn.com/problems/zigzag-conversion/description/" target="_blank" rel="noopener"> Z字形变换 </a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：<br>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”<br>实现一个将字符串进行指定行数变换的函数。</p><hr><p><strong>示例</strong><br>输入: s = “PAYPALISHIRING”, numRows = 3<br>输出: “PAHNAPLSIIGYIR”</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>观察Z字排列可以得出，一个循环依次从原字符串中读取了k = (2 <em> numRows - 2)个字母，并将其排在了第` p &gt; numRows ? ( 2 </em> numRows - p) : p; //p为一次循环中的第p个字母 `列。通过这个规律，我们就可以对字符串进行遍历，依次读取对应位置的字母，最后将其拼接成一个字符串。</p><p>当然还有一个预处理。考虑到最后一个循环可能不是完整的循环，因此我在原本的字符串后面用空格补齐了最后一次循环，然后最后使用字符替换将空格替换成空字符。这样就不用考虑最后一个循环不完整的问题。（其实不考虑这个也可以，直接利用字符串长度进行判断，如果超出了就不取就行了。当时没有想到这个。这就导致了在完成拼接后，还要进行删除操作，这个其实是挺影响效率的。）</p><p>其实就是参考答案中的第二种方法，参考答案写的更简洁。另外有一点会影响运行效率的问题，我在后面的补充中会提到。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">int</span> num = numRows * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>;<span class="hljs-comment">//一次循环的字母数</span><br>        <span class="hljs-keyword">int</span> zCol = s.length() / num + <span class="hljs-number">1</span>;<span class="hljs-comment">//Z字循环的次数，包括最后一次不完整循环</span><br>        String str = s + <span class="hljs-string">""</span>;<span class="hljs-comment">//新建字符串</span><br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<span class="hljs-comment">//指针</span><br>        <span class="hljs-comment">//在新建字符串后面补空格占位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.length() - <span class="hljs-number">1</span>; i &lt; zCol * num; i++) &#123;<br>            str += <span class="hljs-string">" "</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = str.length();<br>        <span class="hljs-comment">//换成字符数组，提升效率</span><br>        <span class="hljs-keyword">char</span>[] strc = str.toCharArray();<br>        String ss = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//Z循环结果的第一行，因为第一行一个循环只有一个，所以单独拿出来了</span><br>        <span class="hljs-keyword">while</span> (p &lt; len) &#123;<br>            ss += strc[p];<br>            p += num;<br>        &#125;<br>        <span class="hljs-comment">//指针重定位</span><br>        p = numRows - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//辅助指针</span><br>        <span class="hljs-keyword">int</span> pp = numRows - <span class="hljs-number">2</span>;<br>        count = len - ss.length();<span class="hljs-comment">//还需要循环多少次</span><br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//把第p-pp行的补上</span><br>            <span class="hljs-keyword">if</span> (pp != <span class="hljs-number">0</span>) &#123;<br>                ss += strc[p - pp];<br>                ss += strc[p + pp];<br>                count -= <span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ss += strc[p];<br>                count--;<br>            &#125;<br>            p += num;<span class="hljs-comment">//指针移动</span><br>            <span class="hljs-keyword">if</span> (p &gt;= len) &#123;<br>                p = numRows - <span class="hljs-number">1</span>;<br>                pp--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ss.replaceAll(<span class="hljs-string">" "</span>,<span class="hljs-string">""</span>);<span class="hljs-comment">//去除空格</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>方法一创建一个长度为numRows长的字符串链表，每链表的每一项代表每一行中应存在的字符串。通过一次遍历，把每个字母加到对应的字符串链表里去。最后再把几个字符串取出来拼在一起就行了。<br>方法二跟我做的方法相同。答案写的更清晰明了，也更简洁。</p><h3 id="补充——String-StringBuilder与StringBuffer"><a href="#补充——String-StringBuilder与StringBuffer" class="headerlink" title="补充——String,StringBuilder与StringBuffer"></a>补充——String,StringBuilder与StringBuffer</h3><p>Java中有三种不同的字符串类型，分别是String,StringBuilder以及StringBuffer。在初学的时候（就是我了），通常只使用到String类型。因为String类型对于平时的写代码已经基本够用了。但是在遇到对效率有一定要求的项目的时候，就需要注意这三种类的区别了。<br>这三种类的最主要的区别在于运行速度和线程安全这两方面。简单说，String的运行效率最低，StringBuilder运行效率最高，即：</p><p></p><p style="text-align:center"> StringBuilder &gt; StringBuffer &gt; String </p><br>而在线程安全性方面，StringBuilder是线程不安全的，StringBuffer是线程安全的，而String是字符串常量，就不存在安不安全的问题，即：<p></p><p></p><p style="text-align:center"> StringBuffer &gt; StringBuilder </p><br>具体的情况，在<a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener"> Java中的String，StringBuilder，StringBuffer三者的区别-酥风 </a>这篇文章中讲述的比较详细，请感兴趣的朋友自行查看。<p></p><h2 id="Code-7-反转整数"><a href="#Code-7-反转整数" class="headerlink" title="Code.7  反转整数 "></a>Code.7 <a href="https://leetcode-cn.com/problems/reverse-integer/description/" target="_blank" rel="noopener"> 反转整数 </a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p><hr><p><strong>示例</strong><br>输入: 123<br>输出: 321</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>把传入的数依次对10求余数，在除以10，循环直到为0，获取每一位上的数字，然后倒过来乘10的k次方。这题比较简单，需要注意的点有两个。第一个是要处理负数，第二个是反转后溢出要置零（我第一次没看清。。以为溢出的就输出最大值。坑了我一次提交记录好气啊！）。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> wei = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> flag = x &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<span class="hljs-comment">//符号位，是否为负数</span><br>        <span class="hljs-keyword">int</span> temp = x &gt; <span class="hljs-number">0</span> ? x : (<span class="hljs-number">0</span> - x);<span class="hljs-comment">//负数的话转正在处理</span><br>        <span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">15</span>];<span class="hljs-comment">//存数字用的。。最大9位数这个量超了</span><br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//求每一位</span><br>            num[wei] = temp % <span class="hljs-number">10</span>;<br>            temp /= <span class="hljs-number">10</span>;<br>            wei++;<br>        &#125;<br>        <span class="hljs-keyword">double</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">//用double类型存反转后的结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = wei - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result += num[wei - i - <span class="hljs-number">1</span>] * Math.pow(<span class="hljs-number">10.0</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123; <span class="hljs-comment">//超过返回0</span><br>            result = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> y = (<span class="hljs-keyword">int</span>)result;<span class="hljs-comment">//转为int类型</span><br>        <span class="hljs-keyword">return</span> flag == <span class="hljs-number">0</span> ? y : (<span class="hljs-number">0</span> - y);<span class="hljs-comment">//记得符号位</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/reverse-integer/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>思路其实是一样的，做法不一样。在取每一位数字后，答案直接进行了乘10处理。这样一次循环就能实现得到结果。而我的做法需要两次循环。</p><p>当然两者的效率差别不大。原因在于数字太小。循环9次和循环18次在计算机看来没有什么太大区别，因此效率就差别不大了。</p><p>不过话说回来，还是要注意这种能以此循环结果的就最好一次就好，数据量大了，多一次循环就是多浪费了一次循环的时间。</p><h2 id="Code-8-字符串转整数-atoi"><a href="#Code-8-字符串转整数-atoi" class="headerlink" title="Code.8  字符串转整数 (atoi) "></a>Code.8 <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/description/" target="_blank" rel="noopener"> 字符串转整数 (atoi) </a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>实现 atoi，将字符串转为整数。<br>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。<br>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。<br>若函数不能执行有效的转换，返回 0。</p><hr><p><strong>示例</strong><br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>问题不大。就暴力解题呗。从头开始判断是不是+、-，然后判断是不是数字，是数字的话有多少位。直到不是数字为止。</p><p>这题的难点倒不是思路，而是各种坑。需要对各种情况考虑周全才能AC，这就比较难受了。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        String s = str.trim();<span class="hljs-comment">//去空格</span><br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'+'</span>) &#123;<span class="hljs-comment">//如果首位是+，长度为1或者第二位是-，就不是数字直接返回0</span><br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span> || s.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">'-'</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            s = s.substring(<span class="hljs-number">1</span>,len);<span class="hljs-comment">//去掉首位的+号</span><br>            len = s.length();<span class="hljs-comment">//其实直接-1就行了。重新计算纯属浪费。。</span><br>        &#125;<br>        <span class="hljs-comment">//情况比较复杂。。如果长度为0、不是-或者数字、只有一个-号都直接返回0</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span> || (s.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">'-'</span> &amp;&amp; (s.charAt(<span class="hljs-number">0</span>) &gt; <span class="hljs-string">'9'</span> || s.charAt(<span class="hljs-number">0</span>) &lt; <span class="hljs-string">'0'</span>)) || (len == <span class="hljs-number">1</span> &amp;&amp; s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'-'</span>) ) &#123;<span class="hljs-comment">//这里其实没有优化。。应该跟上面的＋放在一起来着。。之所以是这样子的是因为这道题的测试中各种稀奇古怪的输入，导致我i错的太多，然后就放飞自我了。。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> flag = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'-'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">//是不是有-号</span><br>        <span class="hljs-keyword">int</span> p = flag;<br>        <span class="hljs-keyword">while</span> (p &lt; len) &#123;<span class="hljs-comment">//循环判断是不是数字，不是退出</span><br>            <span class="hljs-keyword">if</span> (s.charAt(p) &gt; <span class="hljs-string">'9'</span> || s.charAt(p) &lt; <span class="hljs-string">'0'</span>) &#123;<br>                <span class="hljs-keyword">if</span> (p == flag) &#123;<span class="hljs-comment">//判断－号后面是不是字符。。这个应该在上面做判断的。。</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            p++;<br>        &#125;<br>        String nums = s.substring(<span class="hljs-number">0</span>, p);<span class="hljs-comment">//把数字的部分切出来</span><br>        <span class="hljs-keyword">double</span> numd = Double.parseDouble(nums);<span class="hljs-comment">//转成double</span><br>        <span class="hljs-keyword">if</span> (numd &gt;= Integer.MAX_VALUE) &#123;<span class="hljs-comment">//最大溢出返回最大int值</span><br>            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (numd &lt;= Integer.MIN_VALUE) &#123;<span class="hljs-comment">//最小溢出</span><br>            <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">int</span> numi = (<span class="hljs-keyword">int</span>)numd;<span class="hljs-comment">//返回结果</span><br>        <span class="hljs-keyword">return</span> numi;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><p>没有参考答案。如果有机会我再改进改进。<del>改进？不存在的</del></p><h2 id="Code-9-回文数"><a href="#Code-9-回文数" class="headerlink" title="Code.9  回文数 "></a>Code.9 <a href="https://leetcode-cn.com/problems/palindrome-number/description/" target="_blank" rel="noopener"> 回文数 </a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><hr><p><strong>示例</strong><br>输入: 121<br>输出: true</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一道简单题。按照惯例直接暴力解题。</p><p>按照规则，小于0的肯定直接返回<code>false</code>，0~9之间的返回<code>true</code>，剩下的两位数以上的，再进行判断。先求得这个数字的位数，然后获取这个数的两端，判断对应位上的数字是不是相同，不同就返回<code>false</code>，遍历完就返回<code>true</code>。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//小于0的直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">10</span>) &#123;<span class="hljs-comment">//大于0小于10的返回真</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> temp = x;<br>        <span class="hljs-keyword">int</span> wei = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录位数</span><br>        <span class="hljs-keyword">while</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<br>            temp /= <span class="hljs-number">10</span>;<br>            wei++;<br>        &#125;<br>        <span class="hljs-comment">//判断对应位上的数字是否相同</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= (wei / <span class="hljs-number">2</span>); i++) &#123;<br>            <span class="hljs-keyword">if</span> ((x / (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>, i - <span class="hljs-number">1</span>)) % <span class="hljs-number">10</span> != (x / (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>, wei - i)) % <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/palindrome-number/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>将数字对折，判断是不是对称的。想不到还可以这样。</p><p>答案用了半次位数的遍历，我这个算起来得有1.5次。。因为我用了一次遍历来计算位数。</p><h2 id="Code-11-盛最多水的容器"><a href="#Code-11-盛最多水的容器" class="headerlink" title="Code.11  盛最多水的容器 "></a>Code.11 <a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener"> 盛最多水的容器 </a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br><strong>注意</strong>：你不能倾斜容器，n 至少是2。</p><hr><p><strong>示例</strong><br>无</p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>一开始的做法还是暴力法。双指针遍历，找出最大值。然后就超时了= =。。。然后就参考了答案的逼近法。。就是分别让两个指针指向头尾，然后指向小的数的指针向大的数的指针移动，直到相遇。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> Vmax = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来存容积的。。当时考虑到可能容积会溢出int范围，所以使用double。。</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//左指针</span><br>        <span class="hljs-keyword">int</span> right = height.length - <span class="hljs-number">1</span>;<span class="hljs-comment">//右指针</span><br>        <span class="hljs-keyword">while</span> (right &gt; left) &#123;<span class="hljs-comment">//两指针没相遇</span><br>            Vmax = Vmax &gt; Math.min(height[left], height[right]) * (right - left) ? Vmax : Math.min(height[left], height[right]) * (right - left);<span class="hljs-comment">//存容积较大的一个数据</span><br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<span class="hljs-comment">//如果右指针比较大，左指针就向右移</span><br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//否则右指针向左移</span><br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//返回一个int类型的数</span><br>        <span class="hljs-keyword">return</span> Vmax &gt;= Integer.MAX_VALUE ? Integer.MAX_VALUE : (<span class="hljs-keyword">int</span>)Vmax;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-4"><a href="#参考答案-4" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>答案很清晰，建议看答案。答案的动图有助于理解这么逼近为什么会是最大面积。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这周就先这样更新5道题吧。中间跳过去的第10题等之后我想到解决方法了再聊吧。这周主要其实是在学数学，接下去的重点也会放在考研科目的学习上，毕竟还是考研重要。最近每天晚上睡觉的时候，都会有一种强烈的压力。感觉自己要没有书读了。嗨呀，羡慕保研的大佬们！</p><p>现在留下的泪都是当初脑子进的水！！现在羡慕也没用= =还是要努力啊。。向我梦想的实验室努力进发！加油💪！！！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 周记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Week 1</title>
      <link href="/2018/07/15/LeetCode-Week-1/"/>
      <url>/2018/07/15/LeetCode-Week-1/</url>
      
        <content type="html"><![CDATA[<p>这是一个新坑。近期开启了<a href="https://leetcode-cn.com" target="_blank" rel="noopener">LeetCode</a>生涯，主要的原因是自己的代码量不足，写代码有一种难产的感觉。一方面基础语法记得不太清楚，另一方面是思路较为混乱，感觉想的很多，但是动手实现的时候跟不上，这让我觉得很难受。选择Leetcode是因为，刷知乎刷到了一个问题叫<a href="https://www.zhihu.com/question/31092580/answer/442881738" target="_blank" rel="noopener">刷leetcode吃力正常吗？</a>的问题。。然后就一时兴起，就去看了这个oj，看着网站感觉还行，比以前用过的oj清爽<del>（以前的Oj已经弃坑了）</del>，而且在线编辑器也还蛮好看的，可选择的语言也挺多，于是就决定入坑了。</p><p>试做了一题，感觉这个系统做的还是挺人性化的，比以前弃坑的oj好很多的一点是可以在线测试代码结果，和答案结果做比较，可以得到问题可能出现的地方。提交后出错，也会给你最后错误时的输入是什么，就冲这一点我就要吹爆了。大部分oj都不会告诉你错误时最后一次输入是什么，有时候漏了什么细小的条件，是真的很难发现，给出问题所在，就可以根据错误修改，这点真的太重要了，<code>刷题心情++</code>啊！</p><p><strong>那么就开始我们的LeetCode之旅吧！</strong><br><a id="more"></a></p><h2 id="关于Leetcode-Week"><a href="#关于Leetcode-Week" class="headerlink" title="关于Leetcode Week"></a>关于Leetcode Week</h2><p>如果不出意外的话，LeetCode Week系列应该会周更，主要是记录我刷题的一些思路，以及如果有参考答案的话附上对答案的理解。那么下面是第一周的LeetCode解题实例。如果有更好的解题思路，欢迎留言讨论！</p><h2 id="Code-1-两数之和"><a href="#Code-1-两数之和" class="headerlink" title="Code.1 两数之和"></a>Code.1 <a href="https://leetcode-cn.com/problems/two-sum/description/" target="_blank" rel="noopener">两数之和</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><hr><p><strong>示例</strong><br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力解题。用两个指针遍历，组合出所有结果，当得到目标值时，退出循环，返回指针位置的数组。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/two-sum/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>暴力法效率太低，需要遍历两次数组，时间复杂度为O(n^2)，参考答案给出了一种叫做哈希表的解法创建哈希表的时间复杂度为O(n)，理论上利用哈希表查询的时间复杂度为O(1),总计时间复杂度为O(n)，大大提高了效率。<br>解题代码略，详情<a href="https://leetcode-cn.com/problems/two-sum/solution/" target="_blank" rel="noopener">点此查看</a>。</p><h3 id="补充——哈希表"><a href="#补充——哈希表" class="headerlink" title="补充——哈希表"></a>补充——哈希表</h3><blockquote><p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。——百度百科《<a href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/5981869?fr=aladdin" target="_blank" rel="noopener">哈希表</a>》</p></blockquote><p>关于哈希表还有很多可以讲的，但是我其实自己还没有完全弄懂。查看了一些资料现在大致明白哈希表的操作了。</p><p>简单说就是用一个数组链表，将所有数据重新归类存到各个数组指向的链表中。平时查字典时用到的思想差不多。先按照拼音或者部首查询一个大类集合，再在集合里查询，这样能有使原本的全局遍历变成局部的遍历，因此在大量数据查询时，能十分有效地提高搜索效率。</p><p>哈希表的难点在于找到一个合适的哈希函数，使得所有哈希表的分布尽可能的均匀，如果不设置好，极端的情况下，所有的数据都划分到同一个区块中，这样效率就和平时的全局遍历一样了。</p><p>至于如何设置哈希函数，就不是今天讨论的范围了，如果之后有机会的话（我学完了，弄懂了的话），再来分享。</p><p>在本题中，设置的哈希键值为数组的数，键值对应的数据为该键值在数组中的序号。因此在对数组的第i个数放入哈希表时，查询哈希表中键值为<code>target - nums[i]</code>的链表中是否有数据，如果有，就说明找到了两个满足的数，返回键值<code>target - nums[i]</code>对应的数据和<code>i</code>就是题目所需的结果啦。</p><h2 id="Code-2-两数相加"><a href="#Code-2-两数相加" class="headerlink" title="Code.2 两数相加"></a>Code.2 <a href="https://leetcode-cn.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">两数相加</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br>你可以假设除了数字 0之外，这两个数字都不会以零开头。</p><hr><p><strong>示例</strong><br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>还是暴力解题。既然题目还是从个位开始的链表，这也就是说，从各位开始遍历到链表尾就好。而这过程中需要注意的是分类讨论。</p><ol><li>两个链表都不为空/还没链表尾<br>只需要两个对应位的数相加，大于10时，添加一个进位标志，将相加之和取10的余后保存在结果链表中即可。</li><li>一个链表为空/到链表尾<br>空的那部分不管，只需将不为空的那部分与进位相加，如果还有进位再补一个进位。以此类推处理。</li><li>两个链表都为空/都到链表尾了<br>都为空只需要判断还有没有进位，有的话在结果的链表最后补一个进位1。<br>其实下面的代码写的并不是很简洁，但是我暂时想不到什么简洁的写的写法，因此就比较冗长。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     int val;<br> *     ListNode next;<br> *     ListNode(int x) &#123; val = x; &#125;<br> * &#125;<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = l1.val + l2.val;<br>        ListNode sum = <span class="hljs-keyword">new</span> ListNode(temp % <span class="hljs-number">10</span>);<br>        ListNode tempList = sum;<br>        ListNode temp2 = l2.next;<br>        ListNode temp1 = l1.next;<br>        <span class="hljs-keyword">int</span> jingwei = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (temp &gt;= <span class="hljs-number">10</span>) &#123;<br>            jingwei = <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(temp1 != <span class="hljs-keyword">null</span> &amp;&amp; temp2 != <span class="hljs-keyword">null</span>) &#123;<br>            temp = temp1.val + temp2.val;<br>            <span class="hljs-keyword">if</span> (jingwei == <span class="hljs-number">1</span>) &#123;<br>                temp++;<br>                jingwei = <span class="hljs-number">0</span>;<br>            &#125;<br>            tempList.next = <span class="hljs-keyword">new</span> ListNode(temp % <span class="hljs-number">10</span>);<br>            tempList = tempList.next;<br>            temp1 = temp1.next;<br>            temp2 = temp2.next;<br>            <span class="hljs-keyword">if</span> (temp &gt;= <span class="hljs-number">10</span>) &#123;<br>                jingwei = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp1 == <span class="hljs-keyword">null</span> &amp;&amp; temp2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">while</span>(temp2 != <span class="hljs-keyword">null</span>) &#123;<br>                temp = temp2.val + jingwei;<br>                tempList.next = <span class="hljs-keyword">new</span> ListNode(temp % <span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">10</span>) &#123;<br>                    jingwei = <span class="hljs-number">0</span>;<br>                &#125;<br>                tempList = tempList.next;<br>                temp2 = temp2.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp1 != <span class="hljs-keyword">null</span> &amp;&amp; temp2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">while</span>(temp1 != <span class="hljs-keyword">null</span>) &#123;<br>                temp = temp1.val + jingwei;<br>                tempList.next = <span class="hljs-keyword">new</span> ListNode(temp % <span class="hljs-number">10</span>);<br>                 <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">10</span>) &#123;<br>                    jingwei = <span class="hljs-number">0</span>;<br>                &#125;<br>                tempList = tempList.next;<br>                temp1 = temp1.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp1 == <span class="hljs-keyword">null</span> &amp;&amp; temp2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (jingwei == <span class="hljs-number">1</span>) &#123;<br>                tempList.next = <span class="hljs-keyword">new</span> ListNode(jingwei);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>参考答案的做法跟我的做法其实是一个，毕竟这个方法还是比较直观的，效率也较高。不过答案的写法是真的简洁明了，我还是做不到这样的清晰的解题，这也是我想刷题的理由。</p><p>当然，还有一种做法是将链表转化为数字，然后再数字相加，最后再将结果转化为链表表示。这个算法没有做尝试，但是从理论分析上，可以得到转化数字的做法需要遍历的次数是大于上述做法的。</p><h2 id="Code-3-无重复字符的最长子串"><a href="#Code-3-无重复字符的最长子串" class="headerlink" title="Code.3 无重复字符的最长子串"></a>Code.3 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">无重复字符的最长子串</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><hr><p><strong>示例</strong><br>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。<br>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。<br>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串 </p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力解题法。<del>当没有思路时，暴力解题法是你最大的帮手。</del>暴力解题时，使用两个指针划分字串，再判断指针外的字符中是否包含有字串中的字符，然后右指针右移，继续判断，直到指针外出现字串内的字母，记录字串的长度，与记录中的最大值比较。</p><p>滑动窗口法。滑动窗口法是暴力解题法的改进。由于暴力解题时，每一个字母都要从当前位置加1开始遍历，但是其实再上一个最长字串中已经遍历并查询了一部分子串的不重复性，再重新检查这部分的重复性属于重复操作，属于无用功。因此滑动窗口需要在上一个最大子串的基础上，滑动左右指针，这样可以避免已经查询过的子串再重复查询，提升运行效率。</p><p>实际上，一开始我就是使用暴力解题的。使用暴力解题法，效率还是低，结果<code>982 / 983 个通过测试用例</code>，最后一个由于测试的字符串太长了，超时了，就很尴尬。没有办法，百思不得其解，最后看了一下参考答案才恍然大悟。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><strong>暴力法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        String longStr = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>        String key = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            longStr = <span class="hljs-string">""</span> + s.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.length(); j++) &#123;<br>                temp = longStr.indexOf(s.charAt(j));<br>                <span class="hljs-keyword">if</span> (temp &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                longStr += s.charAt(j);<br>            &#125;<br>            maxLen = maxLen &gt; longStr.length() ? maxLen : longStr.length();<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>滑动窗口法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        String longStr = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>        String key = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            longStr = s.substring(i,i + start);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + start; j &lt; s.length(); j++) &#123;<br>                temp = longStr.indexOf(s.charAt(j));<br>                <span class="hljs-keyword">if</span> (temp &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                longStr += s.charAt(j);<br>                start++;<br>            &#125;<br>            maxLen = maxLen &gt; longStr.length() ? maxLen : longStr.length();<br>            start--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>参考答案的最优解是利用hash表，进行一次遍历，以字母为索引，该字母在字符串中的位置为值，建立哈希表，如果该哈希表中已经存在该键值，说明已经包含有重复的，此时记录的值与开始值相减得到长度，与记录的最大值比较。然后再从重复的地方开始继续建立哈希表，并且只在开始的地方做判断。如下所示：<br>字符串：”casdafseds”<br>hash table：</p><table width="600px" border="1"><tr><th width="100px" align="center"> string </th><th width="50px" align="center"> c </th><th width="50px" align="center"> a </th><th width="50px" align="center"> s </th><th width="50px" align="center"> d </th><th width="50px" align="center"> a </th><th width="50px" align="center"> f </th><th width="50px" align="center"> s </th><th width="50px" align="center"> e </th><th width="50px" align="center"> d </th><th width="50px" align="center"> s </th></tr><tr><th align="center"> 键 值</th><td align="center"> c </td><td align="center"> a </td><td align="center"> s </td><td align="center"> d </td><td align="center"> a </td><td align="center"> f </td><td align="center"> s </td><td align="center"> e </td><td align="center"> d </td><td align="center"> s </td></tr><tr><th align="center"> j </th><td align="center"> 0 </td><td align="center"> 1 </td><td align="center"> 2 </td><td align="center"> 3 </td><td align="center"> 4 </td><td align="center"> 5 </td><td align="center"> 6 </td><td align="center"> 7 </td><td align="center"> 8 </td><td align="center"> 9 </td></tr><tr><th align="center"> i </th><td align="center"> 0 </td><td align="center"> 0 </td><td align="center"> 0 </td><td align="center"> 0 </td><td align="center"> 2 </td><td align="center"> 2 </td><td align="center"> 3 </td><td align="center"> 3 </td><td align="center"> 4 </td><td align="center"> 7 </td></tr><tr><th align="center"> ans </th><td align="center"> 1 </td><td align="center"> 2 </td><td align="center"> 3 </td><td align="center"> 4 </td><td align="center"> 4 </td><td align="center"> 4 </td><td align="center"> 4 </td><td align="center"> 5 </td><td align="center"> 5 </td><td align="center"> 5 </td></tr><tr><th align="center"> hash值 </th><td align="center"> 1 </td><td align="center"> 2 </td><td align="center"> 3 </td><td align="center"> 4 </td><td align="center"> <del>2</del> 5 </td><td align="center"> 6 </td><td align="center"> <del>3</del> 7 </td><td align="center"> 8 </td><td align="center"> <del>4</del> 9 </td><td align="center"> <del>7</del> 10 </td></tr></table><p>故返回最长不重复的字符串长度<code>ans = 5；</code><br>这个方法实在是巧妙。我自己肯定是想不出来的。只通过创建哈希表一次遍历就能得到最长不重复子串，实在是佩服。路漫漫其修远兮哇！</p><h2 id="Code-4-两个排序数组的中位数"><a href="#Code-4-两个排序数组的中位数" class="headerlink" title="Code.4 两个排序数组的中位数"></a>Code.4 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">两个排序数组的中位数</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p><hr><p><strong>示例</strong><br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>中位数是 (2 + 3)/2 = 2.5</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑到这两个数组是有序数组，都是从小到大排序的，然后我们又知道两个数组的长度，也就是说我们可以得到总长度<code>Len</code>。那么只要将这“砍去”这两个数组中较小的<code>Len / 2</code>个，就可以得到中位数。<br>下面的代码其实写的还不够简洁，可以继续再优化。但是一次提交就成功了还是很开心的。并且运行效率在所有提交的代码中排在前98%，这是我排名最高的一题了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = nums1.length + nums2.length;<br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> middle1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> middle2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums1.length == <span class="hljs-number">0</span> &amp;&amp; nums2.length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums2[(nums2.length) / <span class="hljs-number">2</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (nums2[(nums2.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] + nums2[(nums2.length) / <span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums2.length == <span class="hljs-number">0</span> &amp;&amp; nums1.length != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums1[(nums1.length) / <span class="hljs-number">2</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (nums1[(nums1.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] + nums1[(nums1.length) / <span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p0 &lt;= (count + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1 &lt; nums1.length &amp;&amp; nums1[p1] &lt; nums2[p2]) &#123;<br>                middle2 = middle1;<br>                middle1 = nums1[p1];<br>                p1++;<br>                <span class="hljs-keyword">if</span> (p1 == nums1.length)&#123;<br>                    p1--;<br>                    nums1[p1] = Integer.MAX_VALUE;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 &lt; nums2.length &amp;&amp; nums1[p1] &gt;= nums2[p2]) &#123;<br>                middle2 = middle1;<br>                middle1 = nums2[p2];<br>                p2++;<br>                <span class="hljs-keyword">if</span> (p2 == nums2.length)&#123;<br>                    p2--;<br>                    nums2[p2] = Integer.MAX_VALUE;<br>                &#125;<br>            &#125; <br>            p0++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> middle2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (middle1 + middle2) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/" target="_blank" rel="noopener">参考答案</a></h3><p>答案用的是一个叫递归法的东西。。由于我觉得我的程序运行效率已经很高了，而且我的思路更清晰，直接砍去不要的那部分就行了，看他的算法似乎挺复杂的样子，我就没有研究看看。有兴趣的同学可以自己研究看看~</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我不行了。要写吐了。没有想到这么多。我已经写了快一下午加一晚上了，居然才写了4题。尴尬。本来这次打算更新5道题的，但是我实在懒得写了。还是下周再继续更新吧。PS：其实我第一周刷了十来题了已经，但是第五题我确实不会。也并不是不会，而是超时了不会优化= =看答案也暂时还没看懂，就很菜。</p><p>LeetCode Week第一周就先这样吧，下周再继续更新吧。以后也差不多会保持一周4~5题左右的速度吧。那就这样啦~下周见！😁</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 周记 </tag>
            
            <tag> Java </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于canvas的网页小游戏</title>
      <link href="/2018/07/08/%E5%9F%BA%E4%BA%8Ecanvas%E7%9A%84%E7%BD%91%E9%A1%B5%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/07/08/%E5%9F%BA%E4%BA%8Ecanvas%E7%9A%84%E7%BD%91%E9%A1%B5%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>期末考试终于结束了，各种事项也到了尾声了<del>（并不）</del>。鸽了一周多的项目记录该补回来了。</p><p>本次的项目是一个利用HTML5中<code>canvas</code>标签的网页小游戏，所有素材由<code>JavaScript</code>语言实时绘制，第一次接触这种操作其实还是蛮好玩的。canvas即画布，利用JavaScript操控“画笔”在canvas中不断绘画，生成一幅一幅画，当画面连续播放时，就成了动画，再结合JavaScript的动作响应，最终成为一个能够响应不同操作的小游戏。闲话不多说，下面分享一下项目的一些情况。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这个项目的初衷是为了装点我的个人博客，现在大家可以在博客页上方导航栏的<a href="https://jackzxj.github.io/jackzhang.github-io/game/" target="_blank" rel="noopener"> Game </a>中玩到这个小游戏。这个小游戏当然不是我原创的，整个游戏是在<a href="http://www.htmleaf.com/Demo/201609013946.html" target="_blank" rel="noopener"> HTML5 Canvas 经典赛车小游戏效果演示 </a>的基础增加了游戏性的相关部分，以及修改了一个源代码中的一个不知道是不是bug的东西。因为不打算做教程方面的讲解，水平还没有到那个程度，因此一下分享的是遇到的问题、解决方法以及一些我个人的理解，完整源码已经放到在我的Github上，有兴趣的同学可以<a href="https://github.com/JackZxj/CarGame" target="_blank" rel="noopener">点击这里</a>查看。自认为写的还是比较有条理性，有什么问题欢迎大佬指正！</p><h2 id="canvas的长宽设置问题"><a href="#canvas的长宽设置问题" class="headerlink" title="canvas的长宽设置问题"></a>canvas的长宽设置问题</h2><p>之前没有用过canvas，因此不知道这个标签的设置和div不一样。div可以在css里设置长宽，但是canvas不能。不是在css里设置长宽了，等价于将canvas拉伸至设置的长宽分辨率。而canvas的默认分辨率为300x150，拉伸后的效果一般都不会很理想。正确的设置方法应该是在声明canvas的时候就设置好长宽。</p><p>几种设置方法以及结果：<br>方法一：<br><figure class="highlight HTML"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-comment">&lt;!-- 直接在创建的时候声明长宽 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"500"</span>&gt;</span>你的浏览器不支持canvas，请更换浏览器后重新打开<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//使用HTML5 Canvas API操作</span><br><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'xxx'</span>);<span class="hljs-comment">//xxx为你要操作的canvas的id</span><br>canvas.width = <span class="hljs-number">500</span>;<br>canvas.width = <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure></p><p>如果使用css设置长宽，则是代表这canvas显示的大小，会默认拉伸或者压缩至设置的分辨率。演示这里就不做了，有兴趣的同学可以自己尝试。</p><p>因此我感觉其实一开始可以把canvas的分辨率设置的稍微高一些，然后再使用css设置显示的时候压缩成一定大小的，这样子在高分辨率的显示器中显示的效果也会较好。当然分辨率高了，渲染的压力自然就大了一些。</p><h2 id="使用带有透明度的画笔绘画"><a href="#使用带有透明度的画笔绘画" class="headerlink" title="使用带有透明度的画笔绘画"></a>使用带有透明度的画笔绘画</h2><p>canvas正如其名，就是一块画布。你不声明清空画布，就会不断地在同一个地方反复绘画。因此颜色带有透明度的话，如果不是一帧一帧清空画布重新绘制，就会不断累积然后变成没有透明度。</p><p>另外这里顺带一提，设置透明度地方法有两个。一个是利用rgba设置，另一个是设置全局透明度。如果使用全局透明度，那么在设置透明度的时候，需要先使用<code>ctx.save()</code>(ctx是你声明的画笔的名称）将之前的画笔设置，然后再使用<code>ctx.globalAlpha=0.2;//范围为0~1</code>设置透明度，在使用完透明度后，用<code>ctx.restore()</code>再返回之前画笔设置，去除透明度，否则的话需要再用一次透明度设置语句，将透明度设回1。</p><p>既然提到<code>save()</code>和<code>restore()</code>，这里就顺便见到讲一下这两个语句。一开始我以为这两个一个用于存画面，一个用于返回上一次存的画面，后来发现并不是。它只是单纯地存了画笔的设置。利用的原理当然是堆栈啦。内存中开一个小单元，save就push进去，restore就pop出来。</p><h2 id="贝塞尔曲线的用处"><a href="#贝塞尔曲线的用处" class="headerlink" title="贝塞尔曲线的用处"></a>贝塞尔曲线的用处</h2><p>在游戏中，有两个地方需要使用到曲线的绘制，一个是路的弯道，另一个是物体沿路的弯道路径移动。</p><p>在计算机中绘制直线简单，两点相连就是了，但是曲线，特别是还能够随着时间改变弯道的曲率的曲线，我对此一点想法都没有。而在<a href="http://www.htmleaf.com/Demo/201609013946.html" target="_blank" rel="noopener"> HTML5 Canvas 经典赛车小游戏效果演示 </a>中，路径的曲线是使用canvas的<code>quadraticCurveTo()</code>绘制的。这个方法的作用是创建一条二次贝塞尔曲线。另外一提，其实在Photoshop中的钢笔工具也是画贝塞尔曲线的工具，我以前还觉得这个曲线怎么不太受控制=-=现在明白了事怎么回事就会操作了。</p><p>关于贝塞尔曲线，概念什么的我就不提了，如果不太明白的可以查看这篇文章就可以得到一个基本的了解：<a href="http://www.html-js.com/article/1628" target="_blank" rel="noopener">贝塞尔曲线扫盲</a>。</p><p>我主要想说的其实是，在之前的一门神学课《数学物理方法》中，我们其实就有提到贝塞尔函数。当时讲的贝塞尔函数是一个n阶的方程。当时对这个并没有什么概念（主要是对神学不知所云），但没想到，贝塞尔函数在计算机中这么有用——很多的光滑曲线都是使用贝塞尔函数绘制的。</p><p>这倒是给我了一个警醒。我们之前大学所学的基础课其实并不是没有用的。正是这些基础课打下了现今的一系列先进工具发展的基础。可惜的是，以前的我没有接触到这些能够直观感受到的用处的时候，根本就没有用心学。下学期考研看来还是要好好学习数学，打好基础哇。</p><p>其实我是一直十分认同<code>学以致用</code>的观点的。但是现在的教学中酥糊普遍都是告诉你，这些事基础课，需要学，会有用的。但是没有告诉你，它能干什么用。当然我觉得，这也并不全是老师的错，在基础课中，确实没有办法一一说明都是做什么用的。有的人用到了，就豁然开朗，有的人用不到，可能一辈子都不知道学了是做什么用的。。。唉。要是有电子辅助记忆就好=-=就不用人力记那么多不知道会不会用到的知识了。。。不发牢骚了。</p><p>下面分享一个好玩的网址——<a href="http://bezier.method.ac/" target="_blank" rel="noopener">The Bezier Game</a>。</p><p>顾名思义，就是一个贝塞尔曲线的小游戏，就是用钢笔工具在规定步骤内完成指定图形的绘制。玩几关这个小游戏就可以对钢笔工具以及贝塞尔曲线的绘制更加了解。</p><h2 id="createPattern内存溢出"><a href="#createPattern内存溢出" class="headerlink" title="createPattern内存溢出"></a>createPattern内存溢出</h2><p><code>createPattern</code>是一个用来做局部重绘的方法，主要是用来绘制马路中间的白色虚线。并且在车前进的时候，白线能够向下移动，产生车辆在前进的错觉。canvas的api中没有绘制虚线的方法，更没有我们需要的这种曲线虚线、上窄下宽的虚线，因此我们就借助两个画布，在第一个画布画好全部的线，然后再第二个画布中抠出路中间的那一部分，让那一部分显示第一个画布的图形即可。因此就利用到了createPattern方法。</p><p>createPattern的具体的原理不太清楚，但是我猜测，应该是类似蒙版的作用。绘制一个蒙版，然后利用这个蒙版覆盖图形。但是在实际应用的时候发现，使用这个函数会使得浏览器的内存占用不断提高，最终使得页面崩溃。不知道是不是我的电脑内存太小？还是由于什么原因（在8g内存的笔记本上测试，只开一个Chrome，内存占用会一直增加到90%，然后就崩溃了。。。），我在百度上搜索了，似乎没有找到相关？在bing国际版中，也没有搜索到相关的页面（可能是我搜索方式有问题？或者是我英语水平太次？）。我自己个人的猜测是，因为我的第一层画布也是不断在绘制的，而我的第二层画布需要以第一层画布为蒙版对路的中线做上色，可能是缺少内存回收机制，新的蒙版不断产生，占用的内存就越来越多，然后就爆内存死掉了。</p><p>这只是我依据我自己的测试初步得到的结论，可能不对，希望有知情的大佬能告知。</p><p>我解决这个问题的办法是使用另一个api等效处理——<code>globalCompositeOperation</code>。这是一个能够对将一个源图像绘制到已有图像上的方法。其常用的属性以及用法，见<a href="http://www.runoob.com/tags/canvas-globalcompositeoperation.html" target="_blank" rel="noopener">菜鸟教程-HTML canvas globalCompositeOperation 属性</a>。我最后就是将第二个画布的路和路中间的线进行异或，就将第二个画布抠出了一条透明的线，这样第一个画布已经画好的线就能透过这个透明窗口显示出来。这是一个比较取巧的方法。并且在我的测试下，使用这个方法占用的内存数不会一直增加，也就不会出现崩溃的情况了。</p><h2 id="canvas上的点击事件以及定位方法"><a href="#canvas上的点击事件以及定位方法" class="headerlink" title="canvas上的点击事件以及定位方法"></a>canvas上的点击事件以及定位方法</h2><p>因为canvas本来就是用JavaScript操作的，因此想要获得canvas上的点击事件，直接给最上层的画布声明一个事件监听器就行了，设施的方法是：<code>canvas.addEventListener(&quot;click&quot;, canvasClick, false)</code>，<code>click</code>是设置监听器为点击的类型，<code>canvasClick</code>是监听器的响应方法，需要自己按照需求编写，<code>false</code>是默认属性，表示事件句柄在冒泡阶段执行，如果是<code>true</code>表示事件句柄在捕获阶段执行。简单说就是同步响应和异步响应啦。</p><p>获取点击事件了还不够，一般我们都是在固定的地方绘制不同的按钮，因此我们需要获得点击事件的相对画布的位置，才能判断并做出不同的响应。</p><p>简答粗暴，我们先获取鼠标点击的位置相对于整个页面的位置，再减去画布相对于页面的位置，得到的就是点击的位置相对于画布的位置坐标。</p><p>获得整个页面的相对位置的属性值，请参考<a href="http://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">菜鸟教程-鼠标/键盘事件对象</a>都有详细的说明。</p><p>获得画布的相对位置的属性值，是利用了Element的一个位置属性，请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>源码很长，大概有800多行，我就不贴了，可以到我的Github上去看，里头已经带了一部分注释了，如果有什么问题欢迎和我联系讨论。第一次自己写的H5小游戏，感觉还是挺好玩的。</p><p>这次的小游戏，最大的认识其实是开发手册的重要性。现在的技术越来越多了，编程语言也日新月异，要记住所有东西其实不切实际，但是当你要用到的时候，你知道去哪里找得到你要的东西，这样你的效率也会飞快。因此在我们写东西之前，最好还是要先找到自己可能需要用到的开发手册或者类似的说明书一类的，这样子应该会更顺利一些。</p><p>不知不觉居然又写了一晚上。。。没有文字功底写出来感觉干巴巴的，不过这也算是半篇技术博文了，就别要求太多了。明天准备学习数学=-=，我们下一个坑见，晚安世界~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
            <tag> Javascript </tag>
            
            <tag> HTML5 </tag>
            
            <tag> 小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介系李没玩过的船新版本</title>
      <link href="/2018/06/17/%E4%BB%8B%E7%B3%BB%E6%9D%8E%E6%B2%A1%E7%8E%A9%E8%BF%87%E7%9A%84%E8%88%B9%E6%96%B0%E7%89%88%E6%9C%AC/"/>
      <url>/2018/06/17/%E4%BB%8B%E7%B3%BB%E6%9D%8E%E6%B2%A1%E7%8E%A9%E8%BF%87%E7%9A%84%E8%88%B9%E6%96%B0%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>折腾了两天，总算是基本完成了整个博客的搭建了。累死我了（叹）  </p><p>花了好长时间，换了一个新皮肤，看着舒服了点。暂时就决定用这个主题了，在此，先感谢<a href="https://sh.alynx.xyz/" target="_blank" rel="noopener"> AlynxZhou </a>先生提供的主题~  </p><p>在开始博客之旅前，还是先总结一下本次建立博客的总过程以及遇到的坑吧。  </p><a id="more"></a><h2 id="点击XX开启博客之旅"><a href="#点击XX开启博客之旅" class="headerlink" title="点击XX开启博客之旅"></a>点击XX开启博客之旅</h2><p>一开始在GitHub上建立初始版本博客是按照<a href="https://www.cnblogs.com/EX32/p/4479712.html" target="_blank" rel="noopener"> EX天亮以后 </a>分享的教程一步一步完成的。到教程结束为止，基本都没有遇到什么问题。虽然中间有一部分教程已经不是最新的版本了，但是步骤基本上是一样的。这边就没有什么好说的。  </p><h2 id="选择路线"><a href="#选择路线" class="headerlink" title="选择路线"></a>选择路线</h2><p>在建立好了第一版本的博客页面后，就是十分纯粹的文本页面，只有文字，没有图片，更没有动画装饰。对于这都8102年了，用这种博客实在是在寒碜了。于是就在网上搜解决办法。  </p><p>其实，上面提到的那篇博文最后已经提到了，可以用<a href="https://jekyllrb.com/" target="_blank" rel="noopener"> Jekyll </a>来设置布局，美化页面。  </p><p>然而要使用Jekyll，就要安装Ruby语言。安装Ruby语言麻烦吗。应该也不麻烦。然而我还是放弃了，因为我不是太喜欢Ruby<del>因为它是日本人创造的</del>。。。<code>快住口，无耻老贼，没有半毛钱技术就开始歧视语言的国籍了?!</code>  </p><p>于是乎，我转向了另一个方式，也就是这个博客现在运行的样式<em>（现在是2018年6月17日，说不定我以后会突然来了性质更换别的方式呢[滑稽]）</em>。现在的博客是利用Hexo<em>（据说来自台湾的小哥？？小声哔哔不瞎说）</em>搭建的，具体的环境配置是参照<a href="https://blog.csdn.net/simba1949/article/details/79252352" target="_blank" rel="noopener"> SIMBA1949 </a>的博客来操作的。里头<a href="http://nodejs.cn/download/" target="_blank" rel="noopener"> node.js </a>的安装流程已经是老版本了，不过话说回来，node.js 的版本迭代速度真是惊人，最新的已经10.4 版本了，我这里下载安装的是10.3 版本。安装流程我就不赘述了，基本是一路next。不过我之前下载一个非安装版本的（即压缩包格式的）似乎是解压即用的，好像是不包含npm（node上的包管理工具，能解决NodeJS代码部署上的很多问题），<strong>关于不含npm这个我不能打包票。我也是第一次应node.js ，可能是我不会用，反正最后我是重新下载了安装版本才进行的下一步</strong>。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>安装好node.js ,使用power shell或者Git或者Node自带的命令控制行都可以进行安装。我这里选用的是在Git Bash中操作。操作的方法还是按照<a href="https://blog.csdn.net/simba1949/article/details/79252352" target="_blank" rel="noopener"> SIMBA1949 </a>博客的第三部分所述的流程执行。直到安装好hexo后，依次输入以下三条指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br>$ npm install<br>$ hexo server<br></code></pre></td></tr></table></figure></p><p>但是我在对hexo进行初始化的时候，出现了问题。问题如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br>INFO  Cloning hexo-starter to C:\Program Files\Hexo<br>Cloning into <span class="hljs-string">'C:\Program Files\Hexo'</span>...<br>C:/Program Files/Hexo/.git: Permission denied<br>WARN  git <span class="hljs-built_in">clone</span> failed. Copying data instead<br>WARN  Failed to install dependencies. Please run <span class="hljs-string">'npm install'</span> manually!<br></code></pre></td></tr></table></figure></p><p>然后再网上搜了很久，似乎很少有人遇到这个问题。搜到了有两个人问题跟我一样，一个提出了问题没有人回答，另一个人直接忽略了，可以继续往下执行npm install<br>没有办法只能自己解决问题。。<br>问题出在“Permission denied”即没有权限（事实证明，学好英语确实是有用的。。。英语渣哭瞎）。于是使用管理员身份重新运行Git，用cd指令进入C:\Program Files\Hexo（这是我设置的Hexo的路径，也就是我放博客的地方，这个路径可以自己设置）<br>注：有一个需要注意的。在cd的时候，带有空格的路径是没有办法直接cd成功的。必须使用“\”转义了才能使用。完整指令应为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> C://Program\ Files/Hexo<br></code></pre></td></tr></table></figure></p><p>在成功解决初始化的问题之后，剩下的两个指令就很顺利的可以完成了。</p><p>另外还有一个小小的可选项。就是npm的源在国外，由于某种因素似乎网络不是很稳定。安装npm插件时很久都美哟响应时，可以考虑使用国内淘宝的镜像源。修改方法是：</p><ul><li><p>查看来源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config get registry<br></code></pre></td></tr></table></figure></li><li><p>永久使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></li><li><p>临时使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm --registry https://registry.npm.taobao.org install express<br></code></pre></td></tr></table></figure></li></ul><p>按照教程中的步骤到Hexo安装完成，执行<code>hexo server</code>后，在浏览器地址栏输入<code>http://localhost:4000/.</code>回车便可以看到hexo的默认主题。这个主题相比于最原始的页面，已经是一个较为现代化的页面了。接下去我就没有继续按照教程中的方法绑定域名之类的，因为我没有买域名。因为直接用GitHub的路径已经直接可以访问了，就先不买域名了。暂时先这么用吧，等以后积累的干货多一点了再去买一个域名绑定。</p><h2 id="穿上一身帅气西装"><a href="#穿上一身帅气西装" class="headerlink" title="穿上一身帅气西装"></a>穿上一身帅气西装</h2><p>新页面已经不错了，但是对美的追求怎么能停滞不前！Hexo有很多大佬做的主题模板，在<a href="https://hexo.io/themes/" target="_blank" rel="noopener"> Hexo.io </a>上可以找到这些模板的预览以及GitHub地址。每个主题都有自己的模板说明，以及安装方法，按照他们的安装方法走应该就行了。</p><p>我这边选择的是Aria。在安装的时候，其实遇到了一点小问题。在修改主题中引用的图片时总是出错，一些元素也没有更新出来。后来才发现是因为我按照作者的文件修改的内容有问题。问题如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br>INFO  Start processing<br>ERROR Theme config load failed.<br>ERROR Process failed: _config.yml<br>YAMLException: bad indentation of a mapping entry at line 6, column 14:<br>       categories: categories/<br>                 ^<br>    at generateError (C:\program files\Hexo\node_modules\js-yaml\lib\js-yaml\loader.js:165:10)<br>······以下省略后方的输出······<br></code></pre></td></tr></table></figure></p><p>这个问题我暂时不知道怎么解决。但是我猜测，是因为我的博客是新建立的，因此分类和标签都是空的，因此生成的结果也是空的。所以目前我的解决方法是先注释掉这两项，等后续我找出解决方法了再进行更新。</p><hr><p>····························一条愚蠢的分割线····························</p><h2 id="2018-06-17-23-30-更新"><a href="#2018-06-17-23-30-更新" class="headerlink" title="2018-06-17 23:30 更新"></a>2018-06-17 23:30 更新</h2><p>我终于找出上面的问题怎么解决了！自己果然还是太菜了！</p><p>错误原因：代码缩进！<br>虽然知道yml的代码缩进非常严格。但是我还是没有注意到这个小问题。。。解决bug前的_config.yml:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">menu:</span><br><span class="hljs-attr">  home:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">  archives:</span> <span class="hljs-string">archives/</span><br><span class="hljs-attr">   categories:</span> <span class="hljs-string">categories/</span><span class="hljs-comment">#问题出在"categories:"前的缩进！去掉缩进的那个空格就行了！</span><br><span class="hljs-attr">   tags:</span> <span class="hljs-string">tags/</span><span class="hljs-comment">#同理</span><br>  <span class="hljs-comment"># about: about/</span><br></code></pre></td></tr></table></figure></p><p>哇。这个真的坑是自己太菜了。。。主题作者给的模板代码如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">menu:</span><br><span class="hljs-attr">  home:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">  archives:</span> <span class="hljs-string">archives/</span><br>  <span class="hljs-comment"># categories: categories/</span><br>  <span class="hljs-comment"># tags: tags/</span><br>  <span class="hljs-comment"># about: about/</span><br></code></pre></td></tr></table></figure></p><p>我天真地以为直接去掉#号就行。。。因为我以为下面三个是子标签。。。就没删除前面地空格。万万没想到这样坑了。。。</p><p>So，以上，我的博客应该是正式建成了hhhh</p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是博客应该是意味着我个人技术生涯的一个新开始。虽然我现在还很菜，还有很多不会做，还有很多想学但是还没头绪或者还没动手开始的东西，但是无论如何，希望今后我能坚持下去。</p><blockquote><p>「人生很短，路还很长，请不要停滞不前！」————写给我自己。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
          <category> Github Pages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Pages </tag>
            
            <tag> Hexo </tag>
            
            <tag> Aria </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/16/hello-world/"/>
      <url>/2018/06/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hello </tag>
            
            <tag> 懒得删 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hey, GitHub</title>
      <link href="/2018/06/16/Hey-GitHub/"/>
      <url>/2018/06/16/Hey-GitHub/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h2 id="开篇-做点有趣的事"><a href="#开篇-做点有趣的事" class="headerlink" title="开篇 - 做点有趣的事"></a>开篇 - 做点有趣的事</h2><p>从之前就一直想要折腾一个自己的个人博客，但是苦于自己技术渣，以及自己时间安排不妥当（拖延癌晚期），就一直咕咕咕。今天晚上洗完澡，又想起了这个事，感觉再这么拖延下去怕是遥遥无期了。于是回宿舍整理了东西（拖延了一会儿），终于决定了在github上搭一个博客！<br><a id="more"></a></p><h2 id="人生还很漫长，总要做一些有趣的事才会有盼头呐！"><a href="#人生还很漫长，总要做一些有趣的事才会有盼头呐！" class="headerlink" title="人生还很漫长，总要做一些有趣的事才会有盼头呐！"></a>人生还很漫长，总要做一些有趣的事才会有盼头呐！</h2><p>那么！</p><h2 id="接下去请多关照啦！"><a href="#接下去请多关照啦！" class="headerlink" title="接下去请多关照啦！"></a>接下去请多关照啦！</h2><p>选择github主要有两个理由：<br>一方面，github免费啊！不要钱先折腾折腾再说~<br>另一方面，github上有好多大佬，想要从小白变强，当然还是多学习学习一下大佬~</p><p>初次使用这个markdown，感觉好不习惯。。。</p><p>第一篇就先这样吧！我先摸索摸索这个玩意~</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
          <category> Github Pages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Pages </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/LeetCodeWeek%E6%A8%A1%E6%9D%BF.html"/>
      <url>/LeetCodeWeek%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<h2 id="Code-N"><a href="#Code-N" class="headerlink" title="Code.N   "></a>Code.N <a href>  </a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><hr><p><strong>示例</strong></p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br></code></pre></td></tr></table></figure><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a><a href>参考答案</a></h3><h3 id="补充——哈希表"><a href="#补充——哈希表" class="headerlink" title="补充——哈希表"></a>补充——哈希表</h3>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Golang学习笔记</title>
      <link href="/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF.html"/>
      <url>/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF.html</url>
      
        <content type="html"><![CDATA[<p>xxx<br><a id="more"></a></p><h2 id="chx-xxx"><a href="#chx-xxx" class="headerlink" title="chx xxx"></a>chx xxx</h2><p>xxx</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>ch2/GoStruct.go</strong><br><figure class="highlight Golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><br><br></code></pre></td></tr></table></figure></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有问题欢迎指出。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>可供参考的资料：<br><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Golang标准库文档</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/favicons/html_code.html"/>
      <url>/favicons/html_code.html</url>
      
        <content type="html"><![CDATA[<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff">]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Need For Speed！！！</title>
      <link href="/game/index.html"/>
      <url>/game/index.html</url>
      
        <content type="html"><![CDATA[<div class="canBox" id="mainDiv"><br>        <canvas id="canvas1" width="800" height="600"></canvas><br>        <canvas id="canvas2" width="800" height="600">Your browser does not support the canvas element.</canvas><br></div><hr><p>这是一个基于<code>canvas</code>的html5小游戏，所有素材都是实时画出来的。<br>使用键盘上下左右操作。<br><code>↑</code>为加速<br><code>↓</code>为减速<br><code>←</code>为左转弯<br><code>→</code>为右转弯<br>吃到硬币<code>+10</code>分<br>吃到汽油<code>+30%</code>血条<br>速度越高得分越多<br>另外如果开到草地上耗油量会增加。</p><h2 id="Have-Fun"><a href="#Have-Fun" class="headerlink" title="Have Fun~"></a>Have Fun~</h2><p>ps：我原来想写一个在线积分记录的。。。这样还能留下最高记录什么的。。。但是不知道在github page上怎么实现。。。如果有大佬有想法请告诉我一声，谢谢！</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
